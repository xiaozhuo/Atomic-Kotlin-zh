(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{381:function(e,n,t){e.exports=t.p+"assets/img/reified-generics.4e311ffc.png"},382:function(e,n,t){e.exports=t.p+"assets/img/erased-generics.44d5e0ea.png"},383:function(e,n,t){e.exports=t.p+"assets/img/variance.b07b08ef.png"},581:function(e,n,t){"use strict";t.r(n);var a=t(44),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"creating-generics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-generics"}},[e._v("#")]),e._v(" Creating Generics")]),e._v(" "),a("blockquote",[a("p",[e._v("Generic code works with types that are “specified later.”")])]),e._v(" "),a("p",[e._v("Ordinary classes and functions work with specific types. If you want code to work across more types, this rigidity can be overconstraining.")]),e._v(" "),a("p",[e._v("[Polymorphism](javascript:void(0)) is an object-oriented generalization tool. You write a function that takes a base-class object as a parameter, then call that function with an object of any class derived from that base class—including classes that haven’t yet been created. Now your function is more general, and useful in more places.")]),e._v(" "),a("p",[e._v("A single hierarchy can be too limiting because you must inherit "),a("em",[e._v("from that hierarchy")]),e._v(" to produce an object that fits your function parameter. If a function parameter is an interface instead of a class, the limitations are loosened to include anything that implements that interface. This gives the client programmer the option of implementing an interface in combination with an existing class—that is, to "),a("em",[e._v("adapt")]),e._v(" an existing class to fit the function. Used this way, interfaces can cut across class hierarchies.")]),e._v(" "),a("p",[e._v("Sometimes even an interface is too restrictive because it forces you to work with only that interface. Your code can be even more general if it works with “some unspecified type,” rather than a particular interface or class. That “unspecified type” is a "),a("em",[e._v("generic type parameter")]),e._v(".")]),e._v(" "),a("p",[e._v("Creating generic types and functions is a fairly complex topic, much of which is outside the scope of this book. This atom attempts to give you just enough background so you aren’t surprised when you come across generic concepts and keywords. If you want to get serious about writing generic types and functions you’ll need to study more advanced resources.")]),e._v(" "),a("h3",{attrs:{id:"any"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#any"}},[e._v("#")]),e._v(" "),a("code",[e._v("Any")])]),e._v(" "),a("p",[a("code",[e._v("Any")]),e._v(" is the root of the Kotlin class hierarchy. Every Kotlin class has "),a("code",[e._v("Any")]),e._v(" as a superclass. One way to work with unspecified types is by passing "),a("code",[e._v("Any")]),e._v(" arguments, and this can sometimes confuse the issue of when to use generics. If "),a("code",[e._v("Any")]),e._v(" works, it’s the simpler solution, and simpler is generally better.")]),e._v(" "),a("p",[e._v("There are two ways to use "),a("code",[e._v("Any")]),e._v(". The first, and most straightforward approach, is when you only need to operate on an "),a("code",[e._v("Any")]),e._v(", and nothing more. This is extremely limiting—"),a("code",[e._v("Any")]),e._v(" has only three member functions: "),a("code",[e._v("equals()")]),e._v(", "),a("code",[e._v("hashCode()")]),e._v(" and "),a("code",[e._v("toString()")]),e._v(". There are also extension functions, but these cannot perform any direct operations on the type. For example, "),a("code",[e._v("apply()")]),e._v(" only applies its function argument to the "),a("code",[e._v("Any")]),e._v(".")]),e._v(" "),a("p",[e._v("If you know the type of the "),a("code",[e._v("Any")]),e._v(", you can cast it and perform type-specific operations. Because this involves run-time type information (as shown in [Downcasting](javascript:void(0))), you risk a runtime error if you pass the wrong type to your function (there’s also a slight performance impact). Sometimes this is justified to gain the benefit of eliminating code duplication.")]),e._v(" "),a("p",[e._v("For example, suppose three types each have the ability to communicate. They come from different libraries so you can’t just put them in the same hierarchy, and they have different function names for communicating:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Speakers.kt\npackage creatinggenerics\nimport atomictest.eq\n\nclass Person {\n  fun speak() = "Hi!"\n}\n\nclass Dog {\n  fun bark() = "Ruff!"\n}\n\nclass Robot {\n  fun communicate() = "Beep!"\n}\n\nfun talk(speaker: Any) = when (speaker) {\n  is Person -> speaker.speak()\n  is Dog -> speaker.bark()\n  is Robot -> speaker.communicate()\n  else -> "Not a talker" // Or exception\n}\n\nfun main() {\n  talk(Person()) eq "Hi!"\n  talk(Dog()) eq "Ruff!"\n  talk(Robot()) eq "Beep!"\n  talk(11) eq "Not a talker"\n}\n')])])]),a("p",[e._v("The "),a("code",[e._v("when")]),e._v(" expression discovers the type of the "),a("code",[e._v("speaker")]),e._v(" and calls the appropriate function. If you don’t think "),a("code",[e._v("talk()")]),e._v(" will ever need to work with additional types, this is a tolerable solution. Otherwise, it requires you to modify "),a("code",[e._v("talk()")]),e._v(" for each new type you add, and to rely on runtime information to discover when you miss something.")]),e._v(" "),a("h3",{attrs:{id:"defining-generics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defining-generics"}},[e._v("#")]),e._v(" Defining Generics")]),e._v(" "),a("p",[e._v("Duplicated code is a candidate for conversion into a generic function or type. You do this by adding angle brackets ("),a("code",[e._v("<>")]),e._v(") containing one or more generic placeholders. Here, the generic placeholder "),a("code",[e._v("T")]),e._v(" represents the unknown type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/DefiningGenerics.kt\npackage creatinggenerics\n\nfun <T> gFunction(arg: T): T = arg\n\nclass GClass<T>(val x: T) {\n  fun f(): T = x\n}\n\nclass GMemberFunction {\n  fun <T> f(arg: T): T = arg\n}\n\ninterface GInterface<T> {\n  val x: T\n  fun f(): T\n}\n\nclass GImplementation<T>(\n  override val x: T\n) : GInterface<T> {\n  override fun f(): T = x\n}\n\nclass ConcreteImplementation\n  : GInterface<String> {\n  override val x: String\n    get() = "x"\n  override fun f() = "f()"\n}\n\nfun basicGenerics() {\n  gFunction("Yellow")\n  gFunction(1)\n  gFunction(Dog()).bark()            // [1]\n  gFunction<Dog>(Dog()).bark()\n\n  GClass("Cyan").f()\n  GClass(11).f()\n  GClass(Dog()).f().bark()           // [2]\n  GClass<Dog>(Dog()).f().bark()\n\n  GMemberFunction().f("Amber")\n  GMemberFunction().f(111)\n  GMemberFunction().f(Dog()).bark()  // [3]\n  GMemberFunction().f<Dog>(Dog()).bark()\n\n  GImplementation("Cyan").f()\n  GImplementation(11).f()\n  GImplementation(Dog()).f().bark()\n\n  ConcreteImplementation().f()\n  ConcreteImplementation().x\n}\n')])])]),a("p",[a("code",[e._v("basicGenerics()")]),e._v(" shows that each generic handles different types:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("gFunction()")]),e._v(" takes a parameter of type "),a("code",[e._v("T")]),e._v(" and returns a "),a("code",[e._v("T")]),e._v(" result.")]),e._v(" "),a("li",[a("code",[e._v("GClass")]),e._v(" stores a "),a("code",[e._v("T")]),e._v(". Its member function "),a("code",[e._v("f()")]),e._v(" returns a "),a("code",[e._v("T")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("GMemberFunction")]),e._v(" parameterizes a member function "),a("em",[e._v("within")]),e._v(" the class, rather than parameterizing the entire class.")]),e._v(" "),a("li",[e._v("You can also define an "),a("code",[e._v("interface")]),e._v(" with generic parameters as shown in "),a("code",[e._v("GInterface")]),e._v(". An implementation of "),a("code",[e._v("GInterface")]),e._v(" can either redefine a type parameter as in "),a("code",[e._v("GImplementation")]),e._v(", or provide a specific type argument, as in "),a("code",[e._v("ConcreteImplementation")]),e._v(".")])]),e._v(" "),a("p",[e._v("Notice in "),a("strong",[e._v("[1]")]),e._v(", "),a("strong",[e._v("[2]")]),e._v(" and "),a("strong",[e._v("[3]")]),e._v(" that we are able to call "),a("code",[e._v("bark()")]),e._v(" on the result, because that result emerges as type "),a("code",[e._v("Dog")]),e._v(".")]),e._v(" "),a("p",[e._v("Consider "),a("strong",[e._v("[1]")]),e._v(", "),a("strong",[e._v("[2]")]),e._v(" and "),a("strong",[e._v("[3]")]),e._v(", and the lines immediately following them. The type "),a("code",[e._v("T")]),e._v(" is determined by type inference for "),a("strong",[e._v("[1]")]),e._v(", "),a("strong",[e._v("[2]")]),e._v(" and "),a("strong",[e._v("[3]")]),e._v(". Sometimes this is not possible if a generic or its invocation is too complex to be parsed by the compiler. In this case you must specify the type(s) using the syntax shown in the lines immediately following "),a("strong",[e._v("[1]")]),e._v(", "),a("strong",[e._v("[2]")]),e._v(" and "),a("strong",[e._v("[3]")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"preserving-type-information"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preserving-type-information"}},[e._v("#")]),e._v(" Preserving Type Information")]),e._v(" "),a("p",[e._v("As you will see later in this atom, code "),a("em",[e._v("within")]),e._v(" generic classes and functions can’t know the type of "),a("code",[e._v("T")]),e._v("—this is called "),a("em",[e._v("erasure")]),e._v(". Generics can be thought of as a way to preserve type information for the return value. This way, you don’t have to write code to explicitly check and cast a return value to the desired type.")]),e._v(" "),a("p",[e._v("A common use of generic code is for containers that hold other objects. Consider a "),a("code",[e._v("CarCrate")]),e._v(" class that acts as a trivial collection by holding and producing a single element of type "),a("code",[e._v("Car")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/CarCrate.kt\npackage creatinggenerics\nimport atomictest.eq\n\nclass Car {\n  override fun toString() = "Car"\n}\n\nclass CarCrate(private var c: Car) {\n  fun put(car: Car) { c = car }\n  fun get(): Car = c\n}\n\nfun main() {\n  val cc = CarCrate(Car())\n  val car: Car = cc.get()\n  car eq "Car"\n}\n')])])]),a("p",[e._v("When we call "),a("code",[e._v("cc.get()")]),e._v(", the result comes back as type "),a("code",[e._v("Car")]),e._v(". We’d like to make this tool available to more objects than just "),a("code",[e._v("Car")]),e._v("s, so we generify this class as "),a("code",[e._v("Crate<T>")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Crate.kt\npackage creatinggenerics\nimport atomictest.eq\n\nopen class Crate<T>(private var contents: T) {\n  fun put(item: T) { contents = item }\n  fun get(): T = contents\n}\n\nfun main() {\n  val cc = Crate(Car())\n  val car: Car = cc.get()\n  car eq "Car"\n}\n')])])]),a("p",[a("code",[e._v("Crate<T>")]),e._v(" ensures that you can only "),a("code",[e._v("put()")]),e._v(" a "),a("code",[e._v("T")]),e._v(" into the "),a("code",[e._v("Crate")]),e._v(", and when you call "),a("code",[e._v("get()")]),e._v(" on that "),a("code",[e._v("Crate")]),e._v(", the result comes back as type "),a("code",[e._v("T")]),e._v(".")]),e._v(" "),a("p",[e._v("We can make a version of "),a("code",[e._v("map()")]),e._v(" for "),a("code",[e._v("Crate")]),e._v(" by defining a generic extension function:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/MapCrate.kt\npackage creatinggenerics\nimport atomictest.eq\n\nfun <T, R> Crate<T>.map(f:(T) -> R): List<R> =\n  listOf(f(get()))\n\nfun main() {\n  Crate(Car()).map { it.toString() + "x" } eq\n    "[Carx]"\n}\n')])])]),a("p",[a("code",[e._v("map()")]),e._v(" returns the "),a("code",[e._v("List")]),e._v(" of results produced by applying "),a("code",[e._v("f()")]),e._v(" to each element in the input sequence. Because "),a("code",[e._v("Crate")]),e._v(" only contains a single element, the result is always a "),a("code",[e._v("List")]),e._v(" of one element. There are two generic arguments: "),a("code",[e._v("T")]),e._v(" for the input value and "),a("code",[e._v("R")]),e._v(" for the result, allowing "),a("code",[e._v("f()")]),e._v(" to produce a result type that is different from the input type.")]),e._v(" "),a("h3",{attrs:{id:"type-parameter-constraints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-parameter-constraints"}},[e._v("#")]),e._v(" Type Parameter Constraints")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("type parameter constraint")]),e._v(" says that the generic argument type must be inherited from the constraint. "),a("code",[e._v("<T : Base>")]),e._v(" means that "),a("code",[e._v("T")]),e._v(" must be of type "),a("code",[e._v("Base")]),e._v(" or something derived from "),a("code",[e._v("Base")]),e._v(". This section shows that using constraints is different from a non-generic type that inherits "),a("code",[e._v("Base")]),e._v(".")]),e._v(" "),a("p",[e._v("Consider a type hierarchy that models different items and ways to dispose of them:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Disposable.kt\npackage creatinggenerics\nimport atomictest.eq\n\ninterface Disposable {\n  val name: String\n  fun action(): String\n}\n\nclass Compost(override val name: String) :\n  Disposable {\n  override fun action() = "Add to composter"\n}\n\ninterface Transport : Disposable\n\nclass Donation(override val name: String) :\n  Transport {\n  override fun action() = "Call for pickup"\n}\n\nclass Recyclable(override val name: String) :\n  Transport {\n  override fun action() = "Put in bin"\n}\n\nclass Landfill(override val name: String) :\n  Transport {\n  override fun action() = "Put in dumpster"\n}\n\nval items = listOf(\n  Compost("Orange Peel"),\n  Compost("Apple Core"),\n  Donation("Couch"),\n  Donation("Clothing"),\n  Recyclable("Plastic"),\n  Recyclable("Metal"),\n  Recyclable("Cardboard"),\n  Landfill("Trash"),\n)\n\nval recyclables =\n  items.filterIsInstance<Recyclable>()\n')])])]),a("p",[e._v("Using a constraint, we can access properties and functions of the constrained type within a generic function:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Constrained.kt\npackage creatinggenerics\nimport atomictest.eq\n\nfun <T: Disposable> nameOf(disposable: T) =\n  disposable.name\n\n// As an extension:\nfun <T: Disposable> T.name() = name\n\nfun main() {\n  recyclables.map { nameOf(it) } eq\n    "[Plastic, Metal, Cardboard]"\n  recyclables.map { it.name() } eq\n    "[Plastic, Metal, Cardboard]"\n}\n')])])]),a("p",[e._v("We cannot access "),a("code",[e._v("name")]),e._v(" without the constraint.")]),e._v(" "),a("p",[e._v("This achieves the same result without generics:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/NonGenericConstraint.kt\npackage creatinggenerics\nimport atomictest.eq\n\nfun nameOf2(disposable: Disposable) =\n  disposable.name\n\nfun Disposable.name2() = name\n\nfun main() {\n  recyclables.map { nameOf2(it) } eq\n    "[Plastic, Metal, Cardboard]"\n  recyclables.map { it.name2() } eq\n    "[Plastic, Metal, Cardboard]"\n}\n')])])]),a("p",[e._v("Why use a constraint instead of ordinary polymorphism? The answer is in the return type. With generics, the return type can be exact, rather than being upcast to the base type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/SameReturnType.kt\npackage creatinggenerics\nimport kotlin.random.Random\n\nprivate val rnd = Random(47)\n\nfun List<Disposable>.aRandom(): Disposable =\n  this[rnd.nextInt(size)]\n\nfun <T: Disposable> List<T>.bRandom(): T =\n  this[rnd.nextInt(size)]\n\nfun <T> List<T>.cRandom(): T =\n  this[rnd.nextInt(size)]\n\nfun sameReturnType() {\n  val a: Disposable = recyclables.aRandom()\n  val b: Recyclable = recyclables.bRandom()\n  val c: Recyclable = recyclables.cRandom()\n}\n")])])]),a("p",[e._v("Without generics, "),a("code",[e._v("aRandom()")]),e._v(" can only produce a base-class "),a("code",[e._v("Disposable")]),e._v(", while both "),a("code",[e._v("bRandom()")]),e._v(" and "),a("code",[e._v("cRandom()")]),e._v(" produce a "),a("code",[e._v("Recyclable")]),e._v(". "),a("code",[e._v("bRandom()")]),e._v(" never accesses any elements of "),a("code",[e._v("T")]),e._v(", therefore its constraint is pointless and it ends up being the same as "),a("code",[e._v("cRandom()")]),e._v(", which doesn’t use a constraint.")]),e._v(" "),a("p",[e._v("The only time you need constraints is if you require "),a("em",[e._v("both")]),e._v(" of the following:")]),e._v(" "),a("ol",[a("li",[e._v("Access a function or property.")]),e._v(" "),a("li",[e._v("Preserve the type when returning it.")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/Constraints.kt\npackage creatinggenerics\nimport kotlin.random.Random\n\nprivate val rnd = Random(47)\n\n// Accesses action() but can't\n// return the exact type:\nfun List<Disposable>.inexact(): Disposable {\n  val d: Disposable = this[rnd.nextInt(size)]\n  d.action()\n  return d\n}\n\n// Can't access action() without a constraint:\nfun <T> List<T>.noAccess(): T {\n  val d: T = this[rnd.nextInt(size)]\n  // d.action()\n  return d\n}\n\n// Access action() and return the exact type:\nfun <T: Disposable> List<T>.both(): T {\n  val d: T = this[rnd.nextInt(size)]\n  d.action()\n  return d\n}\n\nfun constraints() {\n  val i: Disposable = recyclables.inexact()\n  val n: Recyclable = recyclables.noAccess()\n  val b: Recyclable = recyclables.both()\n}\n")])])]),a("p",[a("code",[e._v("inexact()")]),e._v(" is an extension to "),a("code",[e._v("List<Disposable>")]),e._v(", which allows it to access "),a("code",[e._v("action()")]),e._v(", but it is not generic so it can only return the base type "),a("code",[e._v("Disposable")]),e._v(". As a generic, "),a("code",[e._v("noAccess()")]),e._v(" is able to return the exact type of "),a("code",[e._v("T")]),e._v(", but without a constraint it cannot access "),a("code",[e._v("action()")]),e._v(". Only when you add the constraint on "),a("code",[e._v("T")]),e._v(" in "),a("code",[e._v("both()")]),e._v(" are you able to access "),a("code",[e._v("action()")]),e._v(" "),a("em",[e._v("and")]),e._v(" return the exact type "),a("code",[e._v("T")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"type-erasure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-erasure"}},[e._v("#")]),e._v(" Type Erasure")]),e._v(" "),a("p",[e._v("Java compatibility is an essential part of Kotlin. In Java, generics were not part of the original language—they were added years later, after large bodies of code had been written. Forcing generics into Java without breaking existing code required a crucial compromise: the generic types are only available during compilation but are not preserved at runtime—the types are "),a("em",[e._v("erased")]),e._v(". This "),a("em",[e._v("erasure")]),e._v(" affects Kotlin.")]),e._v(" "),a("p",[e._v("Let’s pretend erasure doesn’t happen:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Erasure.kt\npackage creatinggenerics\n\nfun main() {\n  val strings = listOf("a", "b", "c")\n  val all: List<Any> = listOf(1, 2, "x")\n  useList(strings)\n  useList(all)\n}\n\nfun useList(list: List<Any>) {\n  // if (list is List<String>) {}  // [1]\n}\n')])])]),a("p",[e._v("Uncomment line "),a("strong",[e._v("[1]")]),e._v(" and you’ll see the following error: “Cannot check for instance of erased type: "),a("code",[e._v("List<String>")]),e._v("”. You can’t test for the generic type at runtime because the type information has been erased.")]),e._v(" "),a("p",[e._v("If erasure "),a("em",[e._v("didn’t")]),e._v(" happen, the list might look like this, assuming additional type information is placed at the end of the list (it does "),a("strong",[e._v("not")]),e._v(" work this way!):")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(381),alt:"reified generics"}}),e._v(" "),a("p",[e._v("Reified Generics")])]),e._v("\nBecause generic types are erased, type information is *not* stored in the `List`. Instead, both `strings` and `all` are just `List`s, with no additional type information:\n"),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(382),alt:"erased generics"}}),e._v(" "),a("p",[e._v("Erased Generics")])]),e._v(" "),a("p",[e._v("You cannot guess type information from the "),a("code",[e._v("List")]),e._v(" contents without analyzing all elements. Checking only the first element from the second list leads you to incorrectly assume that it’s a "),a("code",[e._v("List<Int>")]),e._v(".")]),e._v(" "),a("p",[e._v("The Kotlin designers decided to follow Java and use erasure, for two reasons:")]),e._v(" "),a("ol",[a("li",[e._v("Java compatibility.")]),e._v(" "),a("li",[e._v("Overhead. Storing generic type information significantly increases the memory occupied by a generic "),a("code",[e._v("List")]),e._v(" or "),a("code",[e._v("Map")]),e._v(". For example, a standard "),a("code",[e._v("Map")]),e._v(" consists of many "),a("code",[e._v("Map.Entry")]),e._v(" objects, and "),a("code",[e._v("Map.Entry")]),e._v(" is a generic class. Thus, if generics were reified everywhere by default, each key and value of every "),a("code",[e._v("Map.Entry")]),e._v(" would contain additional type information.")])]),e._v(" "),a("h3",{attrs:{id:"reification-of-function-type-arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reification-of-function-type-arguments"}},[e._v("#")]),e._v(" Reification of Function Type Arguments")]),e._v(" "),a("p",[e._v("Type information is also erased for generic function calls, which means you can’t do much with a generic parameter inside a function.")]),e._v(" "),a("p",[e._v("To retain type information for function arguments, add the "),a("code",[e._v("reified")]),e._v(" keyword. Consider a function "),a("code",[e._v("a()")]),e._v(" that requires class information to perform its task:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/ReificationA.kt\npackage creatinggenerics\nimport kotlin.reflect.KClass\n\nfun <T: Any> a(kClass: KClass<T>) {\n  // Uses KClass<T>\n}\n")])])]),a("p",[e._v("When we call "),a("code",[e._v("a()")]),e._v(" inside a second generic function "),a("code",[e._v("b()")]),e._v(", we would like to use type information for the generic argument:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/ReificationB.kt\npackage creatinggenerics\n\n// Doesn't compile because of erasure:\n// fun <T: Any> b() = a(T::class)\n")])])]),a("p",[e._v("The type information for "),a("code",[e._v("T")]),e._v(" is erased when this code runs, so "),a("code",[e._v("b()")]),e._v(" won’t compile. You can’t access the class of the generic type parameter inside the function body.")]),e._v(" "),a("p",[e._v("The Java solution is to pass type information into the function by hand:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/ReificationC.kt\npackage creatinggenerics\nimport kotlin.reflect.KClass\n\nfun <T: Any> c(kClass: KClass<T>) = a(kClass)\n\nclass K\n\nval kc = c(K::class)\n")])])]),a("p",[e._v("Passing explicit type information "),a("em",[e._v("should")]),e._v(" be redundant because the compiler knows the type of "),a("code",[e._v("T")]),e._v(", and could silently pass it for you. This is effectively what the "),a("code",[e._v("reified")]),e._v(" keyword does.")]),e._v(" "),a("p",[e._v("To use "),a("code",[e._v("reified")]),e._v(", the function must also be "),a("code",[e._v("inline")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/ReificationD.kt\npackage creatinggenerics\n\ninline fun <reified T: Any> d() = a(T::class)\n\nval kd = d<K>()\n")])])]),a("p",[a("code",[e._v("d()")]),e._v(" produces the same effect as "),a("code",[e._v("c()")]),e._v(", but "),a("code",[e._v("d()")]),e._v(" doesn’t require the class reference as an argument.")]),e._v(" "),a("p",[a("code",[e._v("reified")]),e._v(" tells the compiler to preserve the information about the corresponding type argument. The type information is now available at runtime so you can access it inside the function body.")]),e._v(" "),a("p",[e._v("Reification allows the use of "),a("code",[e._v("is")]),e._v(" with a generic parameter type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/CheckType.kt\npackage creatinggenerics\nimport atomictest.eq\n\ninline fun <reified T> check(t: Any) = t is T\n// fun <T> check1(t: Any) = t is T     // [1]\n\nfun main() {\n  check<String>("1") eq true\n  check<Int>("1") eq false\n}\n')])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" Without "),a("code",[e._v("reified")]),e._v(", the type information is erased so you can’t check whether a given element is an instance of "),a("code",[e._v("T")]),e._v(".")])]),e._v(" "),a("p",[e._v("In the following example, "),a("code",[e._v("select()")]),e._v(" produces the "),a("code",[e._v("name")]),e._v(" of each "),a("code",[e._v("Disposable")]),e._v(" item of a particular subtype. It uses "),a("code",[e._v("reified")]),e._v(" combined with a constraint:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// CreatingGenerics/Select.kt\npackage creatinggenerics\nimport atomictest.eq\n\ninline fun <reified T : Disposable> select() =\n  items.filterIsInstance<T>().map { it.name }\n\nfun main() {\n  select<Compost>() eq\n    "[Orange Peel, Apple Core]"\n  select<Donation>() eq "[Couch, Clothing]"\n  select<Recyclable>() eq\n    "[Plastic, Metal, Cardboard]"\n  select<Landfill>() eq "[Trash]"\n}\n')])])]),a("p",[e._v("The library function "),a("code",[e._v("filterIsInstance()")]),e._v(" is itself defined using the "),a("code",[e._v("reified")]),e._v(" keyword.")]),e._v(" "),a("h3",{attrs:{id:"variance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#variance"}},[e._v("#")]),e._v(" Variance")]),e._v(" "),a("p",[e._v("Combining generics and inheritance produces two dimensions of change. If you have a "),a("code",[e._v("Container<T>")]),e._v(" and you want to assign it to a "),a("code",[e._v("Container<U>")]),e._v(" where "),a("code",[e._v("T")]),e._v(" and "),a("code",[e._v("U")]),e._v(" have an inheritance relationship, you must place constraints upon "),a("code",[e._v("Container")]),e._v(" using the "),a("code",[e._v("in")]),e._v(" or "),a("code",[e._v("out")]),e._v(" "),a("em",[e._v("variance annotations")]),e._v(", depending on how you want to use "),a("code",[e._v("Container")]),e._v(".")]),e._v(" "),a("p",[e._v("Here are three versions of a "),a("code",[e._v("Box")]),e._v(" container: a basic "),a("code",[e._v("Box<T>")]),e._v(", one using "),a("code",[e._v("<in T>")]),e._v(" and one using "),a("code",[e._v("<out T>")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/InAndOutBoxes.kt\npackage variance\n\nclass Box<T>(private var contents: T) {\n  fun put(item: T) { contents = item }\n  fun get(): T = contents\n}\n\nclass InBox<in T>(private var contents: T) {\n  fun put(item: T) { contents = item }\n}\n\nclass OutBox<out T>(private var contents: T) {\n  fun get(): T = contents\n}\n")])])]),a("p",[a("code",[e._v("in T")]),e._v(" means that member functions of the class can only accept arguments of type "),a("code",[e._v("T")]),e._v(", but cannot return values of type "),a("code",[e._v("T")]),e._v(". That is, "),a("code",[e._v("T")]),e._v(" objects can be placed "),a("em",[e._v("into")]),e._v(" an "),a("code",[e._v("InBox")]),e._v(", but cannot come out.")]),e._v(" "),a("p",[a("code",[e._v("out T")]),e._v(" means that member functions can return "),a("code",[e._v("T")]),e._v(" objects, but cannot accept arguments of type "),a("code",[e._v("T")]),e._v("—you cannot place "),a("code",[e._v("T")]),e._v(" objects into an "),a("code",[e._v("OutBox")]),e._v(".")]),e._v(" "),a("p",[e._v("Why do we need these constraints? Consider this hierarchy:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/Pets.kt\npackage variance\n\nopen class Pet\nclass Cat : Pet()\nclass Dog : Pet()\n")])])]),a("p",[a("code",[e._v("Cat")]),e._v(" and "),a("code",[e._v("Dog")]),e._v(" are both subtypes of "),a("code",[e._v("Pet")]),e._v(". Is there a subtyping relation between "),a("code",[e._v("Box<Cat>")]),e._v(" and "),a("code",[e._v("Box<Pet>")]),e._v("? It seems like we should be able to assign, for example, a "),a("code",[e._v("Box")]),e._v(" of "),a("code",[e._v("Cat")]),e._v(" to a "),a("code",[e._v("Box")]),e._v(" of "),a("code",[e._v("Pet")]),e._v(" or to a "),a("code",[e._v("Box")]),e._v(" of "),a("code",[e._v("Any")]),e._v(" (because "),a("code",[e._v("Any")]),e._v(" is a supertype of everything):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/BoxAssignment.kt\npackage variance\n\nval catBox = Box<Cat>(Cat())\n// val petBox: Box<Pet> = catBox\n// val anyBox: Box<Any> = catBox\n")])])]),a("p",[e._v("If Kotlin allowed this, "),a("code",[e._v("petBox")]),e._v(" would have "),a("code",[e._v("put(item: Pet)")]),e._v(". "),a("code",[e._v("Dog")]),e._v(" is also a "),a("code",[e._v("Pet")]),e._v(", so this would allow you to put a "),a("code",[e._v("Dog")]),e._v(" into "),a("code",[e._v("catBox")]),e._v(", violating the “cat-ness” of that "),a("code",[e._v("Box")]),e._v(".")]),e._v(" "),a("p",[e._v("Worse, "),a("code",[e._v("anyBox")]),e._v(" would have "),a("code",[e._v("put(item: Any)")]),e._v(", so you could put an "),a("code",[e._v("Any")]),e._v(" into "),a("code",[e._v("catBox")]),e._v("—the container would have no type safety at all.")]),e._v(" "),a("p",[e._v("If we prevent the use of "),a("code",[e._v("put()")]),e._v(", the assignments are safe because no one can put a "),a("code",[e._v("Dog")]),e._v(" into an "),a("code",[e._v("OutBox<Cat>")]),e._v(". The compiler allows us to assign an "),a("code",[e._v("OutBox<Cat>")]),e._v(" to an "),a("code",[e._v("OutBox<Pet>")]),e._v(" or to an "),a("code",[e._v("OutBox<Any>")]),e._v(", because the "),a("code",[e._v("out")]),e._v(" annotation prevents them from having "),a("code",[e._v("put()")]),e._v(" functions:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/OutBoxAssignment.kt\npackage variance\n\nval outCatBox: OutBox<Cat> = OutBox(Cat())\nval outPetBox: OutBox<Pet> = outCatBox\nval outAnyBox: OutBox<Any> = outCatBox\n\nfun getting() {\n  val cat: Cat = outCatBox.get()\n  val pet: Pet = outPetBox.get()\n  val any: Any = outAnyBox.get()\n}\n")])])]),a("p",[e._v("With no "),a("code",[e._v("put()")]),e._v(", we cannot place a "),a("code",[e._v("Dog")]),e._v(" into an "),a("code",[e._v("OutBox<Cat>")]),e._v(", so its “cat-ness” is preserved.")]),e._v(" "),a("p",[e._v("Without a "),a("code",[e._v("get()")]),e._v(", an "),a("code",[e._v("InBox<Any>")]),e._v(" can be assigned to an "),a("code",[e._v("InBox<Pet>")]),e._v(", an "),a("code",[e._v("InBox<Cat>")]),e._v(" or an "),a("code",[e._v("InBox<Dog>")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/InBoxAssignment.kt\npackage variance\n\nval inBoxAny: InBox<Any> = InBox(Any())\nval inBoxPet: InBox<Pet> = inBoxAny\nval inBoxCat: InBox<Cat> = inBoxAny\nval inBoxDog: InBox<Dog> = inBoxAny\n\nfun main() {\n  inBoxAny.put(Any())\n  inBoxAny.put(Pet())\n  inBoxAny.put(Cat())\n  inBoxAny.put(Dog())\n\n  inBoxPet.put(Pet())\n  inBoxPet.put(Cat())\n  inBoxPet.put(Dog())\n\n  inBoxCat.put(Cat())\n  inBoxDog.put(Dog())\n}\n")])])]),a("p",[e._v("It is safe to "),a("code",[e._v("put()")]),e._v(" an "),a("code",[e._v("Any")]),e._v(", "),a("code",[e._v("Pet")]),e._v(", "),a("code",[e._v("Cat")]),e._v(" or "),a("code",[e._v("Dog")]),e._v(" into an "),a("code",[e._v("InBox<Any>")]),e._v(", while you can only "),a("code",[e._v("put()")]),e._v(" a "),a("code",[e._v("Pet")]),e._v(", "),a("code",[e._v("Cat")]),e._v(" or "),a("code",[e._v("Dog")]),e._v(" into an "),a("code",[e._v("InBox<Pet>")]),e._v(". "),a("code",[e._v("inBoxCat")]),e._v(" and "),a("code",[e._v("inBoxDog")]),e._v(" will only accept "),a("code",[e._v("Cat")]),e._v("s and "),a("code",[e._v("Dog")]),e._v("s, respectively. These are the behaviors we expect for boxes that have those type parameters, and the compiler enforces it.")]),e._v(" "),a("p",[e._v("Here’s a summary of the subtyping relationships for "),a("code",[e._v("Box")]),e._v(", "),a("code",[e._v("OutBox")]),e._v(" and "),a("code",[e._v("InBox")]),e._v(":")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"10%"},attrs:{src:t(383),alt:"variance"}}),e._v(" "),a("p",[e._v("Variance")])]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Box<T>")]),e._v(" is "),a("em",[e._v("invariant")]),e._v(". This means that neither "),a("code",[e._v("Box<Cat>")]),e._v(" nor "),a("code",[e._v("Box<Pet>")]),e._v(" is a subtype of the other, so neither can be assigned to the other.")]),e._v(" "),a("li",[a("code",[e._v("OutBox<out T>")]),e._v(" is "),a("em",[e._v("covariant")]),e._v(". This means that "),a("code",[e._v("OutBox<Cat>")]),e._v(" is a subtype of "),a("code",[e._v("OutBox<Pet>")]),e._v(". When you upcast an "),a("code",[e._v("OutBox<Cat>")]),e._v(" to an "),a("code",[e._v("OutBox<Pet>")]),e._v(", it varies in the "),a("em",[e._v("same")]),e._v(" way as upcasting a "),a("code",[e._v("Cat")]),e._v(" to a "),a("code",[e._v("Pet")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("InBox<in T>")]),e._v(" is "),a("em",[e._v("contravariant")]),e._v(". This means that "),a("code",[e._v("InBox<Pet>")]),e._v(" is a subtype of "),a("code",[e._v("InBox<Cat>")]),e._v(".  When you upcast an "),a("code",[e._v("InBox<Pet>")]),e._v(" to an "),a("code",[e._v("InBox<Cat>")]),e._v(", it varies in the "),a("em",[e._v("opposite")]),e._v(" way as upcasting a "),a("code",[e._v("Cat")]),e._v(" to a "),a("code",[e._v("Pet")]),e._v(".")])]),e._v(" "),a("p",[e._v("A read-only "),a("code",[e._v("List")]),e._v(" from the Kotlin standard library is covariant. You can assign a "),a("code",[e._v("List<Cat>")]),e._v(" to a "),a("code",[e._v("List<Pet>")]),e._v(". A "),a("code",[e._v("MutableList")]),e._v(" is invariant because it contains an "),a("code",[e._v("add()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/CovariantList.kt\npackage variance\n\nfun main() {\n  val catList: List<Cat> = listOf(Cat())\n  val petList: List<Pet> = catList\n  var mutablePetList: MutableList<Pet> =\n    mutableListOf(Cat())\n  mutablePetList.add(Dog())\n  // Type mismatch:\n  // mutablePetList =\n  //    mutableListOf<Cat>(Cat())  // [1]\n}\n")])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" If this assignment worked, we could violate the “cat-ness” of the "),a("code",[e._v("mutableListOf<Cat>")]),e._v(" by adding a "),a("code",[e._v("Dog")]),e._v(".")])]),e._v(" "),a("p",[e._v("Functions can have "),a("em",[e._v("covariant return types")]),e._v(". This means that an overriding function can return a type that’s more specific than the function it overrides:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// CreatingGenerics/CovariantReturnTypes.kt\npackage variance\n\ninterface Parent\ninterface Child : Parent\n\ninterface  X {\n  fun f(): Parent\n}\n\ninterface Y : X {\n  override fun f(): Child\n}\n")])])]),a("p",[e._v("Notice how the overridden "),a("code",[e._v("f()")]),e._v(" in "),a("code",[e._v("Y")]),e._v(" returns a "),a("code",[e._v("Child")]),e._v(", while "),a("code",[e._v("f()")]),e._v(" in "),a("code",[e._v("X")]),e._v(" returns a "),a("code",[e._v("Parent")]),e._v(".")]),e._v(" "),a("p",[e._v("This subsection has only been a light introduction to the topic of "),a("em",[e._v("variance")]),e._v(".")]),e._v(" "),a("ul",[a("li",[e._v("-")])]),e._v(" "),a("p",[e._v("Repeated code is a candidate for generic types or functions. This atom only provides a basic grasp of the ideas—if you need deeper understanding you must find it in a more advanced treatment.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);