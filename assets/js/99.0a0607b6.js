(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{473:function(e,n,t){"use strict";t.r(n);var o=t(44),s=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"inner-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#inner-classes"}},[e._v("#")]),e._v(" Inner Classes")]),e._v(" "),t("blockquote",[t("p",[e._v("Inner classes are like nested classes, but an object of an inner class maintains a reference to the outer class.")])]),e._v(" "),t("p",[e._v("An "),t("code",[e._v("inner")]),e._v(" class has an implicit link to the outer class. In the following example, "),t("code",[e._v("Hotel")]),e._v(" is like "),t("code",[e._v("Airport")]),e._v(" from [Nested Classes](javascript:void(0)), but it uses "),t("code",[e._v("inner")]),e._v(" classes. Note that "),t("code",[e._v("reception")]),e._v(" is part of "),t("code",[e._v("Hotel")]),e._v(", but "),t("code",[e._v("callReception()")]),e._v(", which is a member of the nested class "),t("code",[e._v("Room")]),e._v(", accesses "),t("code",[e._v("reception")]),e._v(" without qualification:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// InnerClasses/Hotel.kt\npackage innerclasses\nimport atomictest.eq\n\nclass Hotel(private val reception: String) {\n  open inner class Room(val id: Int = 0) {\n    // Uses \'reception\' from outer class:\n    fun callReception() =\n      "Room $id Calling $reception"\n  }\n  private inner class Closet : Room()\n  fun closet(): Room = Closet()\n}\n\nfun main() {\n  val nycHotel = Hotel("311")\n  // You need an outer object to\n  // create an instance of the inner class:\n  val room = nycHotel.Room(319)\n  room.callReception() eq\n    "Room 319 Calling 311"\n  val sfHotel = Hotel("0")\n  val closet = sfHotel.closet()\n  closet.callReception() eq "Room 0 Calling 0"\n}\n')])])]),t("p",[e._v("Because "),t("code",[e._v("Closet")]),e._v(" inherits the inner class "),t("code",[e._v("Room")]),e._v(", "),t("code",[e._v("Closet")]),e._v(" must also be an "),t("code",[e._v("inner")]),e._v(" class. Nested classes cannot inherit from "),t("code",[e._v("inner")]),e._v(" classes.")]),e._v(" "),t("p",[t("code",[e._v("Closet")]),e._v(" is "),t("code",[e._v("private")]),e._v(", so it is only visible within the scope of "),t("code",[e._v("Hotel")]),e._v(".")]),e._v(" "),t("p",[e._v("An "),t("code",[e._v("inner")]),e._v(" object keeps a reference to its associated outer object. Thus, when creating an "),t("code",[e._v("inner")]),e._v(" object you must first have an outer object. You cannot create a "),t("code",[e._v("Room")]),e._v(" object without a "),t("code",[e._v("Hotel")]),e._v(" object, as you see with "),t("code",[e._v("nycHotel.Room()")]),e._v(".")]),e._v(" "),t("p",[t("code",[e._v("inner")]),e._v(" "),t("code",[e._v("data")]),e._v(" classes are not allowed.")]),e._v(" "),t("h3",{attrs:{id:"qualified-this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#qualified-this"}},[e._v("#")]),e._v(" Qualified "),t("code",[e._v("this")])]),e._v(" "),t("p",[e._v("One of the benefits of classes is the "),t("code",[e._v("this")]),e._v(" reference. You don’t have to explicitly say “the current object” when you access a property or member function.")]),e._v(" "),t("p",[e._v("With a simple class, the meaning of "),t("code",[e._v("this")]),e._v(" is obvious, but with an "),t("code",[e._v("inner")]),e._v(" class, "),t("code",[e._v("this")]),e._v(" could refer to either the "),t("code",[e._v("inner")]),e._v(" object or an outer object. To resolve this issue, Kotlin provides the "),t("em",[e._v("qualified "),t("code",[e._v("this")])]),e._v(" syntax: "),t("code",[e._v("this")]),e._v(" followed by "),t("code",[e._v("@")]),e._v(" and the name of the target class.")]),e._v(" "),t("p",[e._v("Consider three levels of classes: an outer class "),t("code",[e._v("Fruit")]),e._v(" containing an "),t("code",[e._v("inner")]),e._v(" class "),t("code",[e._v("Seed")]),e._v(", which itself contains an "),t("code",[e._v("inner")]),e._v(" class "),t("code",[e._v("DNA")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// InnerClasses/QualifiedThis.kt\npackage innerclasses\nimport atomictest.eq\nimport typechecking.name\n\nclass Fruit { // Implicit label @Fruit\n  fun changeColor(color: String) =\n    "Fruit $color"\n  fun absorbWater(amount: Int) {}\n  inner class Seed { // Implicit label @Seed\n    fun changeColor(color: String) =\n      "Seed $color"\n    fun germinate() {}\n    fun whichThis() {\n      // Defaults to the current class:\n      this.name eq "Seed"\n      // To clarify, you can redundantly\n      // qualify the default this:\n      this@Seed.name  eq "Seed"\n      // Must explicitly access Fruit:\n      this@Fruit.name  eq "Fruit"\n      // Cannot access a further-inner class:\n      // this@DNA.name\n    }\n    inner class DNA { // Implicit label @DNA\n      fun changeColor(color: String) {\n        // changeColor(color) // Recursive\n        this@Seed.changeColor(color)\n        this@Fruit.changeColor(color)\n      }\n      fun plant() {\n        // Call outer-class functions\n        // Without qualification:\n        germinate()\n        absorbWater(10)\n      }\n      // Extension function:\n      fun Int.grow() { // Implicit label @grow\n        // Default is the Int.grow() receiver:\n        this.name eq "Int"\n        // Redundant qualification:\n        this@grow.name  eq "Int"\n        // You can still access everything:\n        this@DNA.name  eq "DNA"\n        this@Seed.name  eq "Seed"\n        this@Fruit.name  eq "Fruit"\n      }\n      // Extension functions on outer classes:\n      fun Seed.plant() {}\n      fun Fruit.plant() {}\n      fun whichThis() {\n        // Defaults to the current class:\n        this.name eq "DNA"\n        // Redundant qualification:\n        this@DNA.name  eq "DNA"\n        // The others must be explicit:\n        this@Seed.name  eq "Seed"\n        this@Fruit.name  eq "Fruit"\n      }\n    }\n  }\n}\n\n// Extension function:\nfun Fruit.grow(amount: Int) {\n  absorbWater(amount)\n  // Calls Fruit\'s version of changeColor():\n  changeColor("Red") eq "Fruit Red"\n}\n\n// Inner-class extension function:\nfun Fruit.Seed.grow(n: Int) {\n  germinate()\n  // Calls Seed\'s version of changeColor():\n  changeColor("Green") eq "Seed Green"\n}\n\n// Inner-class extension function:\nfun Fruit.Seed.DNA.grow(n: Int) = n.grow()\n\nfun main() {\n  val fruit = Fruit()\n  fruit.grow(4)\n  val seed = fruit.Seed()\n  seed.grow(9)\n  seed.whichThis()\n  val dna = seed.DNA()\n  dna.plant()\n  dna.grow(5)\n  dna.whichThis()\n  dna.changeColor("Purple")\n}\n')])])]),t("p",[t("code",[e._v("Fruit")]),e._v(", "),t("code",[e._v("Seed")]),e._v(" and "),t("code",[e._v("DNA")]),e._v(" all have functions called "),t("code",[e._v("changeColor()")]),e._v(", but there’s no overriding—this is not an inheritance relationship. Because they have the same name and signature, the only way to distinguish them is with a qualified "),t("code",[e._v("this")]),e._v(", as you see in "),t("code",[e._v("DNA")]),e._v("’s "),t("code",[e._v("changeColor()")]),e._v(". Inside "),t("code",[e._v("plant()")]),e._v(", functions in either of the two outer classes can be called without qualification if there are no name collisions.")]),e._v(" "),t("p",[e._v("Even though it’s an extension function, "),t("code",[e._v("grow()")]),e._v(" can still access all the objects in the outer class. "),t("code",[e._v("grow()")]),e._v(" can be called anywhere the "),t("code",[e._v("Fruit.Seed.DNA")]),e._v(" implicit receiver is available; for example, inside an extension function for "),t("code",[e._v("DNA")]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"inner-class-inheritance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#inner-class-inheritance"}},[e._v("#")]),e._v(" Inner Class Inheritance")]),e._v(" "),t("p",[e._v("An inner class can inherit another inner class from a "),t("em",[e._v("different")]),e._v(" outer class. Here, "),t("code",[e._v("Yolk")]),e._v(" in "),t("code",[e._v("BigEgg")]),e._v(" is derived from "),t("code",[e._v("Yolk")]),e._v(" in "),t("code",[e._v("Egg")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// InnerClasses/InnerClassInheritance.kt\npackage innerclasses\nimport atomictest.*\n\nopen class Egg {\n  private var yolk = Yolk()\n  open inner class Yolk {\n    init { trace("Egg.Yolk()") }\n    open fun f() { trace("Egg.Yolk.f()") }\n  }\n  init { trace("New Egg()") }\n  fun insertYolk(y: Yolk) { yolk = y }\n  fun g() { yolk.f() }\n}\n\nclass BigEgg : Egg() {\n  inner class Yolk : Egg.Yolk() {\n    init { trace("BigEgg.Yolk()") }\n    override fun f() {\n      trace("BigEgg.Yolk.f()")\n    }\n  }\n  init { insertYolk(Yolk()) }\n}\n\nfun main() {\n  BigEgg().g()\n  trace eq """\n    Egg.Yolk()\n    New Egg()\n    Egg.Yolk()\n    BigEgg.Yolk()\n    BigEgg.Yolk.f()\n  """\n}\n')])])]),t("p",[t("code",[e._v("BigEgg.Yolk")]),e._v(" explicitly names "),t("code",[e._v("Egg.Yolk")]),e._v(" as its base class, and overrides its "),t("code",[e._v("f()")]),e._v(" member function. The function "),t("code",[e._v("insertYolk()")]),e._v(" allows "),t("code",[e._v("BigEgg")]),e._v(" to upcast one of its own "),t("code",[e._v("Yolk")]),e._v(" objects into the "),t("code",[e._v("yolk")]),e._v(" reference in "),t("code",[e._v("Egg")]),e._v(", so when "),t("code",[e._v("g()")]),e._v(" calls "),t("code",[e._v("yolk.f()")]),e._v(", the overridden version of "),t("code",[e._v("f()")]),e._v(" is used. The second call to "),t("code",[e._v("Egg.Yolk()")]),e._v(" is the base-class constructor call of the "),t("code",[e._v("BigEgg.Yolk")]),e._v(" constructor. You can see that the overridden version of "),t("code",[e._v("f()")]),e._v(" is used when "),t("code",[e._v("g()")]),e._v(" is called.")]),e._v(" "),t("p",[e._v("As a review of object construction, study the "),t("code",[e._v("trace")]),e._v(" output until it makes sense.")]),e._v(" "),t("h3",{attrs:{id:"local-anonymous-inner-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#local-anonymous-inner-classes"}},[e._v("#")]),e._v(" Local & Anonymous Inner Classes")]),e._v(" "),t("p",[e._v("Classes defined inside member functions are called "),t("em",[e._v("local inner classes")]),e._v(". These can also be created anonymously, using an "),t("em",[e._v("object expression")]),e._v(", or using a [SAM conversion](javascript:void(0)). In all cases, the "),t("code",[e._v("inner")]),e._v(" keyword is not used, but is implied:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// InnerClasses/LocalInnerClasses.kt\npackage innerclasses\nimport atomictest.eq\n\nfun interface Pet {\n  fun speak(): String\n}\n\nobject CreatePet {\n  fun home() = " home!"\n  fun dog(): Pet {\n    val say = "Bark"\n    // Local inner class:\n    class Dog : Pet {\n      override fun speak() = say + home()\n    }\n    return Dog()\n  }\n  fun cat(): Pet {\n    val emit = "Meow"\n    // Anonymous inner class:\n    return object: Pet {\n      override fun speak() = emit + home()\n    }\n  }\n  fun hamster(): Pet {\n    val squeak = "Squeak"\n    // SAM conversion:\n    return Pet { squeak + home() }\n  }\n}\n\nfun main() {\n  CreatePet.dog().speak() eq "Bark home!"\n  CreatePet.cat().speak() eq "Meow home!"\n  CreatePet.hamster().speak() eq "Squeak home!"\n}\n')])])]),t("p",[e._v("A local inner class has access to other elements in the function as well as elements in the outer-class object, thus "),t("code",[e._v("say")]),e._v(", "),t("code",[e._v("emit")]),e._v(", "),t("code",[e._v("squeak")]),e._v(" and "),t("code",[e._v("home()")]),e._v(" are available within "),t("code",[e._v("speak()")]),e._v(".")]),e._v(" "),t("p",[e._v("You can identify an anonymous inner class because it uses an object expression, which you see in "),t("code",[e._v("cat()")]),e._v(". It returns an "),t("code",[e._v("object")]),e._v(" of a class inherited from "),t("code",[e._v("Pet")]),e._v(" that overrides "),t("code",[e._v("speak()")]),e._v(". Anonymous inner classes are smaller and more straightforward and do not create a named class that will only be used in one place. Even more compact is a [SAM conversion](javascript:void(0)), as seen in "),t("code",[e._v("hamster()")]),e._v(".")]),e._v(" "),t("p",[e._v("Because inner classes keep a reference to the outer-class object, local inner classes can access all members of the enclosing class:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// InnerClasses/CounterFactory.kt\npackage innerclasses\nimport atomictest.*\n\nfun interface Counter {\n  fun next(): Int\n}\n\nobject CounterFactory {\n  private var count = 0\n  fun new(name: String): Counter {\n    // Local inner class:\n    class Local : Counter {\n      init { trace("Local()") }\n      override fun next(): Int {\n        // Access local identifiers:\n        trace("$name $count")\n        return count++\n      }\n    }\n    return Local()\n  }\n  fun new2(name: String): Counter {\n    // Instance of an anonymous inner class:\n    return object: Counter {\n      init { trace("Counter()") }\n      override fun next(): Int {\n        trace("$name $count")\n        return count++\n      }\n    }\n  }\n  fun new3(name: String): Counter {\n    trace("Counter()")\n    return Counter { // SAM conversion\n      trace("$name $count")\n      count++\n    }\n  }\n}\n\nfun main() {\n  fun test(counter: Counter) {\n    (0..3).forEach { counter.next() }\n  }\n  test(CounterFactory.new("Local"))\n  test(CounterFactory.new2("Anon"))\n  test(CounterFactory.new3("SAM"))\n  trace eq """\n    Local() Local 0 Local 1 Local 2 Local 3\n    Counter() Anon 4 Anon 5 Anon 6 Anon 7\n    Counter() SAM 8 SAM 9 SAM 10 SAM 11\n  """\n}\n')])])]),t("p",[e._v("A "),t("code",[e._v("Counter")]),e._v(" keeps track of a "),t("code",[e._v("count")]),e._v(" and returns the next "),t("code",[e._v("Int")]),e._v(" value. "),t("code",[e._v("new()")]),e._v(", "),t("code",[e._v("new2()")]),e._v(" and "),t("code",[e._v("new3()")]),e._v(" each create a different implementation of the "),t("code",[e._v("Counter")]),e._v(" interface. "),t("code",[e._v("new()")]),e._v(" returns an instance of a named inner class, "),t("code",[e._v("new2()")]),e._v(" returns an instance of an anonymous inner class, and "),t("code",[e._v("new3()")]),e._v(" uses a [SAM conversion](javascript:void(0)) to create an anonymous object. All the resulting "),t("code",[e._v("Counter")]),e._v(" objects have implicit access to the elements of the outer object, thus they are inner classes and not just nested classes. You can see from the output that "),t("code",[e._v("count")]),e._v(" in "),t("code",[e._v("CounterFactory")]),e._v(" is shared by all "),t("code",[e._v("Counter")]),e._v(" objects.")]),e._v(" "),t("p",[e._v("SAM conversions are limited—for example, they do not support "),t("code",[e._v("init")]),e._v(" clauses.")]),e._v(" "),t("ul",[t("li",[e._v("-")])]),e._v(" "),t("p",[e._v("In Kotlin, files can contain multiple top-level classes and functions. Because of this, there’s rarely a need for local classes, so if you do need them they should be basic and straightforward. For example, it’s reasonable to create a simple "),t("code",[e._v("data")]),e._v(" class that’s only used inside a function. If a local class becomes complex, you should probably take it out of the function and make it a regular class.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);