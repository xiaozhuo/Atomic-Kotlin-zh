(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{563:function(e,a,t){"use strict";t.r(a);var n=t(44),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"downcasting"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#downcasting"}},[e._v("#")]),e._v(" Downcasting")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("Downcasting")]),e._v(" discovers the specific type of a previously-upcast object.")])]),e._v(" "),t("p",[e._v("Upcasts are always safe because the base class cannot have a bigger interface than the derived class. Every base-class member is guaranteed to exist and is therefore safe to call. Although object-oriented programming is primarily focused on upcasting, there are situations where downcasting can be a useful and expedient approach.")]),e._v(" "),t("p",[e._v("Downcasting happens at runtime, and is also called "),t("em",[e._v("run-time type identification")]),e._v(" (RTTI).")]),e._v(" "),t("p",[e._v("Consider a class hierarchy where the base type has a narrower interface than the derived types. If you upcast an object to the base type, the compiler no longer knows the specific type. In particular, it cannot know what extended functions are safe to call:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// DownCasting/NarrowingUpcast.kt\npackage downcasting\n\ninterface Base {\n  fun f()\n}\n\nclass Derived1 : Base {\n  override fun f() {}\n  fun g() {}\n}\n\nclass Derived2 : Base {\n  override fun f() {}\n  fun h() {}\n}\n\nfun main() {\n  val b1: Base = Derived1() // Upcast\n  b1.f()    // Part of Base\n  // b1.g() // Not part of Base\n  val b2: Base = Derived2() // Upcast\n  b2.f()    // Part of Base\n  // b2.h() // Not part of Base\n}\n")])])]),t("p",[e._v("To solve this problem, there must be some way to guarantee that a downcast is correct, so you don’t accidentally cast to the wrong type and call a non-existent member.")]),e._v(" "),t("h3",{attrs:{id:"smart-casts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#smart-casts"}},[e._v("#")]),e._v(" Smart Casts")]),e._v(" "),t("p",[e._v("Smart casts in Kotlin are automatic downcasts. The "),t("code",[e._v("is")]),e._v(" keyword checks whether an object is a particular type. Any code within the scope of that check assumes that it "),t("em",[e._v("is")]),e._v(" that type:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// DownCasting/IsKeyword.kt\nimport downcasting.*\n\nfun main() {\n  val b1: Base = Derived1() // Upcast\n  if(b1 is Derived1)\n    b1.g() // Within scope of "is" check\n  val b2: Base = Derived2() // Upcast\n  if(b2 is Derived2)\n    b2.h() // Within scope of "is" check\n}\n')])])]),t("p",[e._v("If "),t("code",[e._v("b1")]),e._v(" is of type "),t("code",[e._v("Derived1")]),e._v(", you can call "),t("code",[e._v("g()")]),e._v(". If "),t("code",[e._v("b2")]),e._v(" is of type "),t("code",[e._v("Derived2")]),e._v(", you can call "),t("code",[e._v("h()")]),e._v(".")]),e._v(" "),t("p",[e._v("Smart casts are especially useful inside "),t("code",[e._v("when")]),e._v(" expressions that use "),t("code",[e._v("is")]),e._v(" to search for the type of the "),t("code",[e._v("when")]),e._v(" argument. Note that, in "),t("code",[e._v("main()")]),e._v(", each specific type is first upcast to a "),t("code",[e._v("Creature")]),e._v(", then passed to "),t("code",[e._v("what()")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// DownCasting/Creature.kt\npackage downcasting\nimport atomictest.eq\n\ninterface Creature\n\nclass Human : Creature {\n  fun greeting() = "I\'m Human"\n}\n\nclass Dog : Creature {\n  fun bark() = "Yip!"\n}\n\nclass Alien : Creature {\n  fun mobility() = "Three legs"\n}\n\nfun what(c: Creature): String =\n  when (c) {\n    is Human -> c.greeting()\n    is Dog -> c.bark()\n    is Alien -> c.mobility()\n    else -> "Something else"\n  }\n\nfun main() {\n  val c: Creature = Human()\n  what(c) eq "I\'m Human"\n  what(Dog()) eq "Yip!"\n  what(Alien()) eq "Three legs"\n  class Who : Creature\n  what(Who()) eq "Something else"\n}\n')])])]),t("p",[e._v("In "),t("code",[e._v("main()")]),e._v(", upcasting happens when assigning a "),t("code",[e._v("Human")]),e._v(" to "),t("code",[e._v("Creature")]),e._v(", passing a "),t("code",[e._v("Dog")]),e._v(" to "),t("code",[e._v("what()")]),e._v(", passing an "),t("code",[e._v("Alien")]),e._v(" to "),t("code",[e._v("what()")]),e._v(", and passing a "),t("code",[e._v("Who")]),e._v(" to "),t("code",[e._v("what()")]),e._v(".")]),e._v(" "),t("p",[e._v("Class hierarchies are traditionally drawn with the base class at the top and derived classes fanning down below it. "),t("code",[e._v("what()")]),e._v(" takes a previously-upcast "),t("code",[e._v("Creature")]),e._v(" and discovers its exact type, thus casting that "),t("code",[e._v("Creature")]),e._v(" object "),t("em",[e._v("down")]),e._v(" the inheritance hierarchy, from the more-general base class to a more-specific derived class.")]),e._v(" "),t("p",[e._v("A "),t("code",[e._v("when")]),e._v(" expression that produces a value requires an "),t("code",[e._v("else")]),e._v(" branch to capture all remaining possibilities. In "),t("code",[e._v("main()")]),e._v(", the "),t("code",[e._v("else")]),e._v(" branch is tested using an instance of the local class "),t("code",[e._v("Who")]),e._v(".")]),e._v(" "),t("p",[e._v("Each branch of the "),t("code",[e._v("when")]),e._v(" uses "),t("code",[e._v("c")]),e._v(" as if it is the type we checked for: calling "),t("code",[e._v("greeting()")]),e._v(" if "),t("code",[e._v("c")]),e._v(" is "),t("code",[e._v("Human")]),e._v(", "),t("code",[e._v("bark()")]),e._v(" if it’s a "),t("code",[e._v("Dog")]),e._v(" and "),t("code",[e._v("mobility()")]),e._v(" if it’s an "),t("code",[e._v("Alien")]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"the-modifiable-reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-modifiable-reference"}},[e._v("#")]),e._v(" The Modifiable Reference")]),e._v(" "),t("p",[e._v("Automatic downcasts are subject to a special constraint. If the base-class reference to the object is modifiable (a "),t("code",[e._v("var")]),e._v("), then there’s a possibility that this reference could be assigned to a different object between the instant that the type is detected and the instant when you call specific functions on the downcast object. That is, the specific type of the object might change between type detection and use.")]),e._v(" "),t("p",[e._v("In the following, "),t("code",[e._v("c")]),e._v(" is the argument to "),t("code",[e._v("when")]),e._v(", and Kotlin insists that this argument be immutable so that it cannot change between the "),t("code",[e._v("is")]),e._v(" expression and the call made after the "),t("code",[e._v("->")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// DownCasting/MutableSmartCast.kt\npackage downcasting\n\nclass SmartCast1(val c: Creature) {\n  fun contact() {\n    when (c) {\n      is Human -> c.greeting()\n      is Dog -> c.bark()\n      is Alien -> c.mobility()\n    }\n  }\n}\n\nclass SmartCast2(var c: Creature) {\n  fun contact() {\n    when (val c = c) {           // [1]\n      is Human -> c.greeting()   // [2]\n      is Dog -> c.bark()\n      is Alien -> c.mobility()\n    }\n  }\n}\n")])])]),t("p",[e._v("The "),t("code",[e._v("c")]),e._v(" constructor argument  is a "),t("code",[e._v("val")]),e._v(" in "),t("code",[e._v("SmartCast1")]),e._v(" and a "),t("code",[e._v("var")]),e._v(" in "),t("code",[e._v("SmartCast2")]),e._v(". In both cases "),t("code",[e._v("c")]),e._v(" is passed into the "),t("code",[e._v("when")]),e._v(" expression, which uses a series of smart casts.")]),e._v(" "),t("p",[e._v("In "),t("strong",[e._v("[1]")]),e._v(", the expression "),t("code",[e._v("val c = c")]),e._v(" looks odd, and only used here for convenience—we don’t recommend “shadowing” identifier names in normal code. "),t("code",[e._v("val c")]),e._v(" creates a new local identifier "),t("code",[e._v("c")]),e._v(" that captures the value of the property "),t("code",[e._v("c")]),e._v(". However, the property "),t("code",[e._v("c")]),e._v(" is a "),t("code",[e._v("var")]),e._v(" while the local (shadowed) "),t("code",[e._v("c")]),e._v(" is a "),t("code",[e._v("val")]),e._v(". Try removing the "),t("code",[e._v("val c =")]),e._v(". This means that the "),t("code",[e._v("c")]),e._v(" will now be the property, which is a "),t("code",[e._v("var")]),e._v(". This produces an error message for line "),t("strong",[e._v("[2]")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("Smart cast to ‘Human’ is impossible, because ‘c’ is a mutable property that could have been changed by this time")])])]),e._v(" "),t("p",[t("code",[e._v("is Dog")]),e._v(" and "),t("code",[e._v("is Alien")]),e._v(" produce similar messages. This is not limited to "),t("code",[e._v("while")]),e._v(" expressions; there are other situations that can produce the same error message.")]),e._v(" "),t("p",[e._v("The change described in the error message typically happens through "),t("em",[e._v("concurrency")]),e._v(", when multiple independent tasks have the opportunity to change "),t("code",[e._v("c")]),e._v(" at unpredictable times. (Concurrency is an advanced topic that we do not cover in this book).")]),e._v(" "),t("p",[e._v("Kotlin forces us to ensure that "),t("code",[e._v("c")]),e._v(" will not change from the time that the "),t("code",[e._v("is")]),e._v(" check is performed and the time that "),t("code",[e._v("c")]),e._v(" is used as the downcast type. "),t("code",[e._v("SmartCast1")]),e._v(" does this by making the "),t("code",[e._v("c")]),e._v(" property a "),t("code",[e._v("val")]),e._v(", and "),t("code",[e._v("SmartCast2")]),e._v(" does it by introducing the local "),t("code",[e._v("val c")]),e._v(".")]),e._v(" "),t("p",[e._v("Similarly, complex expressions cannot be smart-cast because the expression might be re-evaluated. Properties that are "),t("code",[e._v("open")]),e._v(" for inheritance can’t be smart-cast because their value might be overridden in subclasses, so there’s no guarantee the value will be the same on the next access.")]),e._v(" "),t("h3",{attrs:{id:"the-as-keyword"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-as-keyword"}},[e._v("#")]),e._v(" The "),t("code",[e._v("as")]),e._v(" Keyword")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("as")]),e._v(" keyword forcefully casts a general type to a specific type:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// DownCasting/Unsafe.kt\npackage downcasting\nimport atomictest.*\n\nfun dogBarkUnsafe(c: Creature) =\n  (c as Dog).bark()\n\nfun dogBarkUnsafe2(c: Creature): String {\n  c as Dog\n  c.bark()\n  return c.bark() + c.bark()\n}\n\nfun main() {\n  dogBarkUnsafe(Dog()) eq "Yip!"\n  dogBarkUnsafe2(Dog()) eq "Yip!Yip!"\n  (capture {\n    dogBarkUnsafe(Human())\n  }) contains listOf("ClassCastException")\n}\n')])])]),t("p",[t("code",[e._v("dogBarkUnsafe2()")]),e._v(" shows a second form of "),t("code",[e._v("as")]),e._v(": if you say "),t("code",[e._v("c as Dog")]),e._v(", then "),t("code",[e._v("c")]),e._v(" is treated as a "),t("code",[e._v("Dog")]),e._v(" throughout the rest of the scope.")]),e._v(" "),t("p",[e._v("A failing "),t("code",[e._v("as")]),e._v(" cast throws a "),t("code",[e._v("ClassCastException")]),e._v(". A plain "),t("code",[e._v("as")]),e._v(" is called an "),t("em",[e._v("unsafe cast")]),e._v(".")]),e._v(" "),t("p",[e._v("When a "),t("em",[e._v("safe cast")]),e._v(" "),t("code",[e._v("as?")]),e._v(" fails, it doesn’t throw an exception, but instead returns "),t("code",[e._v("null")]),e._v(". You must then do something reasonable with that "),t("code",[e._v("null")]),e._v(" to prevent a later "),t("code",[e._v("NullPointerException")]),e._v(". The Elvis operator (described in [Safe Calls & the Elvis Operator](javascript:void(0))) is usually the most straightforward approach:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// DownCasting/Safe.kt\npackage downcasting\nimport atomictest.eq\n\nfun dogBarkSafe(c: Creature) =\n  (c as? Dog)?.bark() ?: "Not a Dog"\n\nfun main() {\n  dogBarkSafe(Dog()) eq "Yip!"\n  dogBarkSafe(Human()) eq "Not a Dog"\n}\n')])])]),t("p",[e._v("If "),t("code",[e._v("c")]),e._v(" is not a "),t("code",[e._v("Dog")]),e._v(", "),t("code",[e._v("as?")]),e._v(" produces a "),t("code",[e._v("null")]),e._v(". Thus, "),t("code",[e._v("(c as? Dog)")]),e._v(" is a nullable expression and we must use the safe call operator "),t("code",[e._v("?.")]),e._v(" to call "),t("code",[e._v("bark()")]),e._v(". If "),t("code",[e._v("as?")]),e._v(" produces a "),t("code",[e._v("null")]),e._v(", then the whole expression "),t("code",[e._v("(c as? Dog)?.bark()")]),e._v(" will also produce a "),t("code",[e._v("null")]),e._v(", which the Elvis operator handles by producing "),t("code",[e._v('"Not a Dog"')]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"discovering-types-in-lists"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#discovering-types-in-lists"}},[e._v("#")]),e._v(" Discovering Types in Lists")]),e._v(" "),t("p",[e._v("When used in a predicate, "),t("code",[e._v("is")]),e._v(" finds objects of a given type within a "),t("code",[e._v("List")]),e._v(", or any "),t("em",[e._v("iterable")]),e._v(" (something you can iterate through):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// DownCasting/FindType.kt\npackage downcasting\nimport atomictest.eq\n\nval group: List<Creature> = listOf(\n  Human(), Human(), Dog(), Alien(), Dog()\n)\n\nfun main() {\n  val dog = group\n    .find { it is Dog } as Dog?    // [1]\n  dog?.bark() eq "Yip!"            // [2]\n}\n')])])]),t("p",[e._v("Because "),t("code",[e._v("group")]),e._v(" contains "),t("code",[e._v("Creature")]),e._v("s, "),t("code",[e._v("find()")]),e._v(" returns a "),t("code",[e._v("Creature")]),e._v(". We want to treat it as a "),t("code",[e._v("Dog")]),e._v(", so we explicitly cast it at the end of line "),t("strong",[e._v("[1]")]),e._v(". There might be zero "),t("code",[e._v("Dog")]),e._v("s in "),t("code",[e._v("group")]),e._v(", in which case "),t("code",[e._v("find()")]),e._v(" returns a "),t("code",[e._v("null")]),e._v(" so we must cast the result to a nullable "),t("code",[e._v("Dog?")]),e._v(". Because "),t("code",[e._v("dog")]),e._v(" is nullable, we use the safe call operator in line "),t("strong",[e._v("[2]")]),e._v(".")]),e._v(" "),t("p",[e._v("You can usually avoid the code in line "),t("strong",[e._v("[1]")]),e._v(" by using "),t("code",[e._v("filterIsInstance()")]),e._v(", which produces all elements of a specific type:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// DownCasting/FilterIsInstance.kt\nimport downcasting.*\nimport atomictest.eq\n\nfun main() {\n  val humans1: List<Creature> =\n    group.filter { it is Human }\n  humans1.size eq 2\n  val humans2: List<Human> =\n    group.filterIsInstance<Human>()\n  humans2 eq humans1\n}\n")])])]),t("p",[t("code",[e._v("filterIsInstance()")]),e._v(" is a more readable way to produce the same result as "),t("code",[e._v("filter()")]),e._v(". However, the result types are different: while "),t("code",[e._v("filter()")]),e._v(" returns a "),t("code",[e._v("List")]),e._v(" of "),t("code",[e._v("Creature")]),e._v(" (even though all the resulting elements are "),t("code",[e._v("Human")]),e._v("), "),t("code",[e._v("filterIsInstance()")]),e._v(" returns a list of the target type "),t("code",[e._v("Human")]),e._v(". We’ve also eliminated the nullability issues seen in "),t("code",[e._v("FindType.kt")]),e._v(".")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);