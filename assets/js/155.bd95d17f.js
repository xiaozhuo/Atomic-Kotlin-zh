(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{533:function(e,n,a){"use strict";a.r(n);var l=a(44),t=Object(l.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"safe-calls-the-elvis-operator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#safe-calls-the-elvis-operator"}},[e._v("#")]),e._v(" Safe Calls & the Elvis Operator")]),e._v(" "),a("blockquote",[a("p",[e._v("Kotlin provides convenient operations for handling nullability.")])]),e._v(" "),a("p",[e._v("Nullable types come with numerous restrictions. You can’t simply dereference an identifier of a nullable type:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// SafeCallsAndElvis/DereferenceNull.kt\n\nfun main() {\n  val s: String? = null\n  // Doesn't compile:\n  // s.length        // [1]\n}\n")])])]),a("p",[e._v("Uncommenting "),a("strong",[e._v("[1]")]),e._v(" produces a compile-time error: "),a("em",[e._v("Only safe ("),a("code",[e._v("?.")]),e._v(") or non-null asserted ("),a("code",[e._v("!!.")]),e._v(") calls are allowed on a nullable receiver of type "),a("code",[e._v("String?")]),e._v(".")])]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("safe call")]),e._v(" replaces the dot ("),a("code",[e._v(".")]),e._v(") in a regular call with a question mark and a dot ("),a("code",[e._v("?.")]),e._v("), without intervening space. Safe calls access members of a nullable in a way that ensures no exceptions are thrown. They only perform an operation when the receiver is not "),a("code",[e._v("null")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SafeCallsAndElvis/SafeOperation.kt\npackage safecalls\nimport atomictest.*\n\nfun String.echo() {\n  trace(toUpperCase())\n  trace(this)\n  trace(toLowerCase())\n}\n\nfun main() {\n  val s1: String? = "Howdy!"\n  s1?.echo()                  // [1]\n  val s2: String? = null\n  s2?.echo()                  // [2]\n  trace eq """\n    HOWDY!\n    Howdy!\n    howdy!\n  """\n}\n')])])]),a("p",[e._v("Line "),a("strong",[e._v("[1]")]),e._v(" calls "),a("code",[e._v("echo()")]),e._v(" and produces results in the "),a("code",[e._v("trace")]),e._v(", while line "),a("strong",[e._v("[2]")]),e._v(" does nothing because the receiver "),a("code",[e._v("s2")]),e._v(" is "),a("code",[e._v("null")]),e._v(".")]),e._v(" "),a("p",[e._v("Safe calls are a clean way to capture results:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SafeCallsAndElvis/SafeCall.kt\npackage safecalls\nimport atomictest.eq\n\nfun checkLength(s: String?, expected: Int?) {\n  val length1 =\n    if (s != null) s.length else null  // [1]\n  val length2 = s?.length              // [2]\n  length1 eq expected\n  length2 eq expected\n}\n\nfun main() {\n  checkLength("abc", 3)\n  checkLength(null, null)\n}\n')])])]),a("p",[e._v("Line "),a("strong",[e._v("[2]")]),e._v(" achieves the same effect as line "),a("strong",[e._v("[1]")]),e._v(". If the receiver is not "),a("code",[e._v("null")]),e._v(" it performs a normal access ("),a("code",[e._v("s.length")]),e._v("). If the receiver is "),a("code",[e._v("null")]),e._v(" it doesn’t perform the "),a("code",[e._v("s.length")]),e._v(" call (which would cause an exception), but produces "),a("code",[e._v("null")]),e._v(" for the expression.")]),e._v(" "),a("p",[e._v("What if you need something more than the "),a("code",[e._v("null")]),e._v(" produced by "),a("code",[e._v("?.")]),e._v("? The "),a("em",[e._v("Elvis operator")]),e._v(" provides an alternative. This operator is a question mark followed by a colon ("),a("code",[e._v("?:")]),e._v("), with no intervening space. It is named for an emoticon of the musician Elvis Presley, and is also a play on the words “else-if” (which sounds vaguely like “Elvis”).")]),e._v(" "),a("p",[e._v("A number of programming languages provide a "),a("em",[e._v("null coalescing operator")]),e._v(" that performs the same action as Kotlin’s Elvis operator.")]),e._v(" "),a("p",[e._v("If the expression on the left of "),a("code",[e._v("?:")]),e._v(" is not "),a("code",[e._v("null")]),e._v(", that expression becomes the result. If the left-hand expression "),a("em",[e._v("is")]),e._v(" "),a("code",[e._v("null")]),e._v(", then the expression on the right of the "),a("code",[e._v("?:")]),e._v(" becomes the result:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SafeCallsAndElvis/ElvisOperator.kt\nimport atomictest.eq\n\nfun main() {\n  val s1: String? = "abc"\n  (s1 ?: "---") eq "abc"\n\n  val s2: String? = null\n  (s2 ?: "---") eq "---"\n}\n')])])]),a("p",[a("code",[e._v("s1")]),e._v(" is not "),a("code",[e._v("null")]),e._v(", so the Elvis operator produces "),a("code",[e._v('"abc"')]),e._v(" as the result. Because "),a("code",[e._v("s2")]),e._v(" is "),a("code",[e._v("null")]),e._v(", the Elvis operator produces the alternate result of "),a("code",[e._v('"---"')]),e._v(".")]),e._v(" "),a("p",[e._v("The Elvis operator is typically used after a safe call, to produce a meaningful value instead of the default "),a("code",[e._v("null")]),e._v(", as you see in "),a("strong",[e._v("[2]")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SafeCallsAndElvis/ElvisCall.kt\npackage safecalls\nimport atomictest.eq\n\nfun checkLength(s: String?, expected: Int) {\n  val length1 =\n    if (s != null) s.length else 0    // [1]\n  val length2 = s?.length ?: 0        // [2]\n  length1 eq expected\n  length2 eq expected\n}\n\nfun main() {\n  checkLength("abc", 3)\n  checkLength(null, 0)\n}\n')])])]),a("p",[e._v("This "),a("code",[e._v("checkLength()")]),e._v(" function is quite similar to the one in "),a("code",[e._v("SafeCall.kt")]),e._v(" above. The "),a("code",[e._v("expected")]),e._v(" parameter type is now non-nullable. "),a("strong",[e._v("[1]")]),e._v(" and "),a("strong",[e._v("[2]")]),e._v(" produce zero instead of "),a("code",[e._v("null")]),e._v(".")]),e._v(" "),a("p",[e._v("Safe calls allow you to write chained calls concisely, when some elements in the chain might be "),a("code",[e._v("null")]),e._v(" and you’re only interested in the final result:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// SafeCallsAndElvis/ChainedCalls.kt\npackage safecalls\nimport atomictest.eq\n\nclass Person(\n  val name: String,\n  var friend: Person? = null\n)\n\nfun main() {\n  val alice = Person("Alice")\n  alice.friend?.friend?.name eq null   // [1]\n\n  val bob = Person("Bob")\n  val charlie = Person("Charlie", bob)\n  bob.friend = charlie\n  bob.friend?.friend?.name eq "Bob"    // [2]\n\n  (alice.friend?.friend?.name\n    ?: "Unknown") eq "Unknown"         // [3]\n}\n')])])]),a("p",[e._v("When you chain access to several members using safe calls, the result is "),a("code",[e._v("null")]),e._v(" if any intermediate expressions are "),a("code",[e._v("null")]),e._v(".")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" The property "),a("code",[e._v("alice.friend")]),e._v(" is "),a("code",[e._v("null")]),e._v(", so the rest of the calls return  "),a("code",[e._v("null")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("[2]")]),e._v(" All intermediate calls produce meaningful values.")]),e._v(" "),a("li",[a("strong",[e._v("[3]")]),e._v(" An Elvis operator after the chain of safe calls provides an alternate value if any intermediate element is "),a("code",[e._v("null")]),e._v(".")])]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);