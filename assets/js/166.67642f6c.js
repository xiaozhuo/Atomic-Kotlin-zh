(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{544:function(e,n,t){"use strict";t.r(n);var a=t(44),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"higher-order-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#higher-order-functions"}},[e._v("#")]),e._v(" Higher-Order Functions")]),e._v(" "),t("blockquote",[t("p",[e._v("A language supports "),t("em",[e._v("higher-order functions")]),e._v(" if its functions can accept other functions as arguments and produce functions as return values.")])]),e._v(" "),t("p",[e._v("Higher-order functions are an essential part of functional programming languages. In previous atoms, we’ve seen higher-order functions such as "),t("code",[e._v("filter()")]),e._v(", "),t("code",[e._v("map()")]),e._v(", and "),t("code",[e._v("any()")]),e._v(".")]),e._v(" "),t("p",[e._v("You can store a lambda in a reference. Let’s look at the type of this storage:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// HigherOrderFunctions/IsPlus.kt\npackage higherorderfunctions\nimport atomictest.eq\n\nval isPlus: (Int) -> Boolean = { it > 0 }\n\nfun main() {\n  listOf(1, 2, -3).any(isPlus) eq true\n}\n")])])]),t("p",[t("code",[e._v("(Int) -> Boolean")]),e._v(" is the function type: it starts with parentheses surrounding zero or more parameter types, then an arrow ("),t("code",[e._v("->")]),e._v("), followed by the return type:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(Arg1Type, Arg2Type... ArgNType) -> ReturnType\n")])])]),t("p",[e._v("The syntax for calling a function through a reference is identical to an ordinary function call:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/CallingReference.kt\npackage higherorderfunctions\nimport atomictest.eq\n\nval helloWorld: () -> String =\n  { "Hello, world!" }\n\nval sum: (Int, Int) -> Int =\n  { x, y -> x + y }\n\nfun main() {\n  helloWorld() eq "Hello, world!"\n  sum(1, 2) eq 3\n}\n')])])]),t("p",[e._v("When a function accepts a function parameter, you can either pass it a function reference or a lambda. Consider how you might define "),t("code",[e._v("any()")]),e._v(" from the standard library:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/Any.kt\npackage higherorderfunctions\nimport atomictest.eq\n\nfun <T> List<T>.any(                    // [1]\n  predicate: (T) -> Boolean             // [2]\n): Boolean {\n  for (element in this) {\n    if (predicate(element))             // [3]\n      return true\n  }\n  return false\n}\n\nfun main() {\n  val ints = listOf(1, 2, -3)\n  ints.any { it > 0 } eq true           // [4]\n\n  val strings = listOf("abc", " ")\n  strings.any { it.isBlank() } eq true  // [5]\n  strings.any(String::isNotBlank) eq    // [6]\n    true\n}\n')])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" "),t("code",[e._v("any()")]),e._v(" should be usable with "),t("code",[e._v("List")]),e._v("s of different types so we define it as an extension to the generic "),t("code",[e._v("List<T>")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" The "),t("code",[e._v("predicate")]),e._v(" function is callable with a parameter of type "),t("code",[e._v("T")]),e._v(" so we can apply it to the "),t("code",[e._v("List")]),e._v(" elements.")]),e._v(" "),t("li",[t("strong",[e._v("[3]")]),e._v(" Applying "),t("code",[e._v("predicate()")]),e._v(" tells whether that "),t("code",[e._v("element")]),e._v(" fits our criteria.")]),e._v(" "),t("li",[e._v("The type of the lambda differs: it’s "),t("code",[e._v("Int")]),e._v(" in "),t("strong",[e._v("[4]")]),e._v(" and "),t("code",[e._v("String")]),e._v(" in "),t("strong",[e._v("[5]")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[6]")]),e._v(" A member reference is another way to pass a function reference.")])]),e._v(" "),t("p",[t("code",[e._v("repeat()")]),e._v(" from the standard library takes a function as its second parameter. It repeats an action an "),t("code",[e._v("Int")]),e._v(" number of times:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/RepeatByInt.kt\nimport atomictest.*\n\nfun main() {\n  repeat(4) { trace("hi!") }\n  trace eq "hi! hi! hi! hi!"\n}\n')])])]),t("p",[e._v("Consider how "),t("code",[e._v("repeat()")]),e._v(" might be defined:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/Repeat.kt\npackage higherorderfunctions\nimport atomictest.*\n\nfun repeat(\n  times: Int,\n  action: (Int) -> Unit           // [1]\n) {\n  for (index in 0 until times) {\n    action(index)                 // [2]\n  }\n}\n\nfun main() {\n  repeat(3) { trace("#$it") }     // [3]\n  trace eq "#0 #1 #2"\n}\n')])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" "),t("code",[e._v("repeat()")]),e._v(" takes a parameter "),t("code",[e._v("action")]),e._v(" of the function type "),t("code",[e._v("(Int) -> Unit")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" When "),t("code",[e._v("action()")]),e._v(" is called, it is passed the current repetition "),t("code",[e._v("index")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[3]")]),e._v(" When calling "),t("code",[e._v("repeat()")]),e._v(", you access the repetition "),t("code",[e._v("index")]),e._v(" using "),t("code",[e._v("it")]),e._v(" inside the lambda.")])]),e._v(" "),t("p",[e._v("A function return type can be nullable:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/NullableReturn.kt\nimport atomictest.eq\n\nfun main() {\n  val transform: (String) -> Int? =\n    { s: String -> s.toIntOrNull() }\n  transform("112") eq 112\n  transform("abc") eq null\n  val x = listOf("112", "abc")\n  x.mapNotNull(transform) eq "[112]"\n  x.mapNotNull { it.toIntOrNull() } eq "[112]"\n}\n')])])]),t("p",[t("code",[e._v("toIntOrNull()")]),e._v(" might return "),t("code",[e._v("null")]),e._v(", so "),t("code",[e._v("transform()")]),e._v(" accepts a "),t("code",[e._v("String")]),e._v(" and returns a nullable "),t("code",[e._v("Int?")]),e._v(". "),t("code",[e._v("mapNotNull()")]),e._v(" converts each element in a "),t("code",[e._v("List")]),e._v(" into a nullable value and removes all "),t("code",[e._v("null")]),e._v("s from the result. It has the same effect as first calling "),t("code",[e._v("map()")]),e._v(", then applying "),t("code",[e._v("filterNotNull()")]),e._v(" to the resulting list.")]),e._v(" "),t("p",[e._v("Note the difference between making the return type nullable versus making the whole function type nullable:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// HigherOrderFunctions/NullableFunction.kt\nimport atomictest.eq\n\nfun main() {\n  val returnTypeNullable: (String) -> Int? =\n    { null }\n  val mightBeNull: ((String) -> Int)? = null\n  returnTypeNullable("abc") eq null\n  // Doesn\'t compile without a null check:\n  // mightBeNull("abc")\n  if (mightBeNull != null) {\n    mightBeNull("abc")\n  }\n}\n')])])]),t("p",[e._v("Before calling the function stored in "),t("code",[e._v("mightBeNull")]),e._v(", we must ensure that the function reference itself is not "),t("code",[e._v("null")]),e._v(".")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);