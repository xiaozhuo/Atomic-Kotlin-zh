(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{578:function(n,e,a){"use strict";a.r(e);var t=a(44),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"extension-lambdas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extension-lambdas"}},[n._v("#")]),n._v(" Extension Lambdas")]),n._v(" "),a("blockquote",[a("p",[n._v("An extension lambda is like an extension function. It defines a lambda instead of a function.")])]),n._v(" "),a("p",[n._v("Here, "),a("code",[n._v("va")]),n._v(" and "),a("code",[n._v("vb")]),n._v(" yield the same result:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// ExtensionLambdas/Vanbo.kt\npackage extensionlambdas\nimport atomictest.eq\n\nval va: (String, Int) -> String = { str, n ->\n  str.repeat(n) + str.repeat(n)\n}\n\nval vb: String.(Int) -> String = {\n  this.repeat(it) + repeat(it)\n}\n\nfun main() {\n  va("Vanbo", 2) eq "VanboVanboVanboVanbo"\n  "Vanbo".vb(2) eq "VanboVanboVanboVanbo"\n  vb("Vanbo", 2) eq "VanboVanboVanboVanbo"\n  // "Vanbo".va(2) // Doesn\'t compile\n}\n')])])]),a("p",[a("code",[n._v("va")]),n._v(" is an ordinary lambda like the ones you’ve seen throughout this book. It takes two parameters, a "),a("code",[n._v("String")]),n._v(" and an "),a("code",[n._v("Int")]),n._v(", and returns a "),a("code",[n._v("String")]),n._v(". The lambda body also has two parameters, followed by the requisite arrow: "),a("code",[n._v("str, n ->")]),n._v(".")]),n._v(" "),a("p",[a("code",[n._v("vb")]),n._v(" moves the "),a("code",[n._v("String")]),n._v(" parameter outside the parentheses and uses extension function syntax: "),a("code",[n._v("String.(Int)")]),n._v(". Just like an [extension function](javascript:void(0)), the object of the type being extended ("),a("code",[n._v("String")]),n._v(", in this case), becomes the "),a("em",[n._v("receiver")]),n._v(", and can be accessed using "),a("code",[n._v("this")]),n._v(".")]),n._v(" "),a("p",[n._v("The first call in "),a("code",[n._v("vb")]),n._v(" uses the explicit form "),a("code",[n._v("this.repeat(it)")]),n._v(". The second call omits the "),a("code",[n._v("this")]),n._v(" to produce "),a("code",[n._v("repeat(it)")]),n._v(". Like any lambda, if you have only one parameter ("),a("code",[n._v("Int")]),n._v(", in this case), "),a("code",[n._v("it")]),n._v(" refers to that parameter.")]),n._v(" "),a("p",[n._v("In "),a("code",[n._v("main()")]),n._v(", the call to "),a("code",[n._v("va()")]),n._v(" is just what you’d expect from the lambda type declaration "),a("code",[n._v("(String, Int) -> String")]),n._v("—two arguments in a traditional function call. "),a("code",[n._v("vb()")]),n._v(" is an extension so it can be called using the extension form "),a("code",[n._v('"Vanbo".vb(2)')]),n._v(". "),a("code",[n._v("vb()")]),n._v(" can "),a("em",[n._v("also")]),n._v(" be called using the traditional form "),a("code",[n._v('vb("Vanbo", 2)')]),n._v(". "),a("code",[n._v("va()")]),n._v(" cannot be called using the extension form.")]),n._v(" "),a("p",[n._v("When you first see an extension lambda, it can seem like the "),a("code",[n._v("String.(Int)")]),n._v(" part is what you should focus on. But "),a("code",[n._v("String")]),n._v(" is not being extended by the parameter list "),a("code",[n._v("(Int)")]),n._v("—it is being extended by the entire lambda: String."),a("strong",[n._v("(Int) -> String")])]),n._v(" "),a("p",[n._v("The Kotlin documentation usually refers to extension lambdas as "),a("em",[n._v("function literals with receiver")]),n._v(". The term "),a("em",[n._v("function literal")]),n._v(" encompasses both lambdas and anonymous functions. The term "),a("em",[n._v("lambda with receiver")]),n._v(" is often used synonymously for "),a("em",[n._v("extension lambda")]),n._v(", to emphasize that it’s a lambda with the receiver as an additional implicit parameter.")]),n._v(" "),a("p",[n._v("Like an extension function, an extension lambda can have multiple parameters:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/Parameters.kt\npackage extensionlambdas\nimport atomictest.eq\n\nval zero: Int.() -> Boolean = {\n  this == 0\n}\n\nval one: Int.(Int) -> Boolean = {\n  this % it == 0\n}\n\nval two: Int.(Int, Int) -> Boolean = {\n  arg1, arg2 ->\n    this % (arg1 + arg2) == 0\n}\n\nval three: Int.(Int, Int, Int) -> Boolean = {\n  arg1, arg2, arg3 ->\n    this % (arg1 + arg2 + arg3) == 0\n}\n\nfun main() {\n  0.zero() eq true\n  10.one(10) eq true\n  20.two(10, 10) eq true\n  30.three(10, 10, 10) eq true\n}\n")])])]),a("p",[n._v("In "),a("code",[n._v("one()")]),n._v(", "),a("code",[n._v("it")]),n._v(" is used instead of naming the parameter. If this produces unclear syntax, it’s better to use explicit parameter names.")]),n._v(" "),a("p",[n._v("We’ve been demonstrating extension lambdas by defining "),a("code",[n._v("val")]),n._v("s, but they more commonly appear as function parameters, as in "),a("code",[n._v("f2()")]),n._v(":")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/FunctionParameters.kt\npackage extensionlambdas\n\nclass A {\n  fun af() = 1\n}\n\nclass B {\n  fun bf() = 2\n}\n\nfun f1(lambda: (A, B) -> Int) =\n  lambda(A(), B())\n\nfun f2(lambda: A.(B) -> Int) =\n  A().lambda(B())\n\nfun lambdas() {\n  f1 { aa, bb -> aa.af() + bb.bf() }\n  f2 { af() + it.bf() }\n}\n")])])]),a("p",[n._v("In "),a("code",[n._v("main()")]),n._v(", notice the more succinct syntax in the lambda provided to "),a("code",[n._v("f2()")]),n._v(".")]),n._v(" "),a("p",[n._v("If your extension lambda returns "),a("code",[n._v("Unit")]),n._v(", the result produced by the lambda body is ignored:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// ExtensionLambdas/LambdaUnitReturn.kt\npackage extensionlambdas\n\nfun unitReturn(lambda: A.() -> Unit) =\n  A().lambda()\n\nfun nonUnitReturn(lambda: A.() -> String) =\n  A().lambda()\n\nfun lambdaUnitReturn () {\n  unitReturn {\n    "Unit ignores the return value" +\n    "So it can be anything ..."\n  }\n  unitReturn { 1 } // ... of any type ...\n  unitReturn { }   // ... or nothing\n  nonUnitReturn {\n    "Must return the proper type"\n  }\n  // nonUnitReturn { } // Not an option\n}\n')])])]),a("p",[n._v("You can pass an extension lambda to a function that expects an ordinary lambda, as long as the parameter lists conform to each other:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// ExtensionLambdas/Transform.kt\npackage extensionlambdas\nimport atomictest.eq\n\nfun String.transform1(\n  n: Int, lambda: (String, Int) -> String\n) = lambda(this, n)\n\nfun String.transform2(\n  n: Int, lambda: String.(Int) -> String\n) = lambda(this, n)\n\nval duplicate: String.(Int) -> String = {\n  repeat(it)\n}\n\nval alternate: String.(Int) -> String = {\n  toCharArray()\n    .filterIndexed { i, _ -> i % it == 0 }\n    .joinToString("")\n}\n\nfun main() {\n  "hello".transform1(5, duplicate)\n    .transform2(3, alternate) eq "hleolhleo"\n  "hello".transform2(5, duplicate)\n    .transform1(3, alternate) eq "hleolhleo"\n}\n')])])]),a("p",[a("code",[n._v("transform1()")]),n._v(" expects an ordinary lambda while "),a("code",[n._v("transform2()")]),n._v(" expects an extension lambda. In "),a("code",[n._v("main()")]),n._v(", the extension lambdas "),a("code",[n._v("duplicate")]),n._v(" and "),a("code",[n._v("alternate")]),n._v(" are passed to both "),a("code",[n._v("transform1()")]),n._v(" and "),a("code",[n._v("transform2()")]),n._v(". The "),a("code",[n._v("this")]),n._v(" receiver inside the extension lambdas "),a("code",[n._v("duplicate")]),n._v(" and "),a("code",[n._v("alternate")]),n._v(" becomes the first "),a("code",[n._v("String")]),n._v(" argument when either lambda is passed to "),a("code",[n._v("transform1()")]),n._v(".")]),n._v(" "),a("p",[n._v("Using "),a("code",[n._v("::")]),n._v(" we can pass a function reference when an extension lambda is expected:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/FuncReferences.kt\npackage extensionlambdas\nimport atomictest.eq\n\nfun Int.d1(f: (Int) -> Int) = f(this) * 10\n\nfun Int.d2(f: Int.() -> Int) = f() * 10\n\nfun f1(n: Int) = n + 3\nfun Int.f2() = this + 3\n\nfun main() {\n  74.d1(::f1) eq 770\n  74.d2(::f1) eq 770\n  74.d1(Int::f2) eq 770\n  74.d2(Int::f2) eq 770\n}\n")])])]),a("p",[n._v("A reference to an extension function has the same type as an extension lambda: "),a("code",[n._v("Int::f2")]),n._v(" has the type "),a("code",[n._v("Int.() -> Int")]),n._v(".")]),n._v(" "),a("p",[n._v("In the call "),a("code",[n._v("74.d1(Int::f2)")]),n._v(" we pass an extension function to "),a("code",[n._v("d1()")]),n._v(" which does not declare an extension lambda parameter.")]),n._v(" "),a("p",[n._v("Polymorphism works with both ordinary extension functions ("),a("code",[n._v("Base.g()")]),n._v(") and extension lambdas (the "),a("code",[n._v("Base.h()")]),n._v(" parameter):")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/ExtensionPolymorphism.kt\npackage extensionlambdas\nimport atomictest.eq\n\nopen class Base {\n  open fun f() = 1\n}\n\nclass Derived : Base() {\n  override fun f() = 99\n}\n\nfun Base.g() = f()\n\nfun Base.h(xl: Base.() -> Int) = xl()\n\nfun main() {\n  val b: Base = Derived() // Upcast\n  b.g() eq 99\n  b.h { f() } eq 99\n}\n")])])]),a("p",[n._v("You wouldn’t expect it "),a("em",[n._v("not")]),n._v(" to work, but it’s always worth testing an assumption by creating an example.")]),n._v(" "),a("p",[n._v("You can use anonymous function syntax (described in [Local Functions](javascript:void(0))) instead of extension lambdas. Here we use an anonymous extension function:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/AnonymousFunction.kt\npackage extensionlambdas\nimport atomictest.eq\n\nfun exec(\n  arg1: Int, arg2: Int,\n  f: Int.(Int) -> Boolean\n) = arg1.f(arg2)\n\nfun main() {\n  exec(10, 2, fun Int.(d: Int): Boolean {\n    return this % d == 0\n  }) eq true\n}\n")])])]),a("p",[n._v("In "),a("code",[n._v("main()")]),n._v(", the call to "),a("code",[n._v("exec()")]),n._v(" shows that the anonymous extension function is accepted as an extension lambda.")]),n._v(" "),a("p",[n._v("The Kotlin standard library contains a number of functions that work with extension lambdas. For example, a "),a("code",[n._v("StringBuilder")]),n._v(" is a modifiable object that produces an immutable "),a("code",[n._v("String")]),n._v(" when you call "),a("code",[n._v("toString()")]),n._v(". In contrast, the more modern "),a("code",[n._v("buildString()")]),n._v(" accepts an extension lambda. It creates its own "),a("code",[n._v("StringBuilder")]),n._v(" object, applies the extension lambda to that object, then calls "),a("code",[n._v("toString()")]),n._v(" to produce the result:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/StringCreation.kt\npackage extensionlambdas\nimport atomictest.eq\n\nprivate fun messy(): String {\n  val built = StringBuilder()      // [1]\n  built.append(\"ABCs: \")\n  ('a'..'x').forEach { built.append(it) }\n  return built.toString()          // [2]\n}\n\nprivate fun clean() = buildString {\n  append(\"ABCs: \")\n  ('a'..'x').forEach { append(it) }\n}\n\nprivate fun cleaner() =\n  ('a'..'x').joinToString(\"\", \"ABCs: \")\n\nfun main() {\n  messy() eq \"ABCs: abcdefghijklmnopqrstuvwx\"\n  messy() eq clean()\n  clean() eq cleaner()\n}\n")])])]),a("p",[n._v("In "),a("code",[n._v("messy()")]),n._v(" we repeat the name "),a("code",[n._v("built")]),n._v(" multiple times. We must also create a "),a("code",[n._v("StringBuilder")]),n._v(" ("),a("strong",[n._v("[1]")]),n._v(") and produce the result ("),a("strong",[n._v("[2]")]),n._v("). Using "),a("code",[n._v("buildString()")]),n._v(" in "),a("code",[n._v("clean()")]),n._v(", you don’t need to create and manage the receiver for the "),a("code",[n._v("append()")]),n._v(" calls, which makes everything much more succinct.")]),n._v(" "),a("p",[a("code",[n._v("cleaner()")]),n._v(" shows that, if you look, you can sometimes find a more direct solution that skips the builder altogether.")]),n._v(" "),a("p",[n._v("There are standard library functions similar to "),a("code",[n._v("buildString()")]),n._v(" that use extension lambdas to produce initialized, read-only "),a("code",[n._v("List")]),n._v("s and "),a("code",[n._v("Map")]),n._v("s:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// ExtensionLambdas/ListsAndMaps.kt\n@file:OptIn(ExperimentalStdlibApi::class)\npackage extensionlambdas\nimport atomictest.eq\n\nval characters: List<String> = buildList {\n  add(\"Chars:\")\n  ('a'..'d').forEach { add(\"$it\") }\n}\n\nval charmap: Map<Char, Int> = buildMap {\n  ('A'..'F').forEachIndexed { n, ch ->\n    put(ch, n)\n  }\n}\n\nfun main() {\n  characters eq \"[Chars:, a, b, c, d]\"\n  //  characters eq characters2\n  charmap eq \"{A=0, B=1, C=2, D=3, E=4, F=5}\"\n}\n")])])]),a("p",[n._v("Inside the extension lambdas, the "),a("code",[n._v("List")]),n._v(" and "),a("code",[n._v("Map")]),n._v(" are mutable, but the results of "),a("code",[n._v("buildList")]),n._v(" and "),a("code",[n._v("buildMap")]),n._v(" are read-only "),a("code",[n._v("List")]),n._v("s and "),a("code",[n._v("Map")]),n._v("s.")]),n._v(" "),a("h3",{attrs:{id:"writing-builders-using-extension-lambdas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#writing-builders-using-extension-lambdas"}},[n._v("#")]),n._v(" Writing Builders Using Extension Lambdas")]),n._v(" "),a("p",[n._v("Hypothetically, you can create constructors to produce all necessary object configurations. Sometimes the number of possibilities makes this messy and impractical. The "),a("em",[n._v("Builder")]),n._v(" pattern has several benefits:")]),n._v(" "),a("ol",[a("li",[n._v("It creates objects in a multi-step process. This can sometimes be helpful when object construction is complex.")]),n._v(" "),a("li",[n._v("It produces different object variations using the same basic construction code.")]),n._v(" "),a("li",[n._v("It separates common construction code from specialized code, making it easier to write and read the code for individual object variations.")])]),n._v(" "),a("p",[n._v("Implementing builders using extension lambdas provides an additional benefit, which is the creation of a "),a("em",[n._v("Domain-Specific Language")]),n._v(" (DSL). The goal of a DSL is syntax that is comfortable and sensible to a user who is a domain expert rather than a programming expert. This allows that user to produce working solutions knowing only a small subset of the surrounding language—while at the same time benefiting from the structure and safety of that language.")]),n._v(" "),a("p",[n._v("For example, consider a system that captures actions and ingredients for preparing different kinds of sandwiches. We can use classes to model the pieces of a "),a("code",[n._v("Recipe")]),n._v(":")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// ExtensionLambdas/Sandwich.kt\npackage sandwich\nimport atomictest.eq\n\nopen class Recipe : ArrayList<RecipeUnit>()\n\nopen class RecipeUnit {\n  override fun toString() =\n    "${this::class.simpleName}"\n}\n\nopen class Operation : RecipeUnit()\nclass Toast : Operation()\nclass Grill : Operation()\nclass Cut : Operation()\n\nopen class Ingredient : RecipeUnit()\nclass Bread : Ingredient()\nclass PeanutButter : Ingredient()\nclass GrapeJelly : Ingredient()\nclass Ham : Ingredient()\nclass Swiss : Ingredient()\nclass Mustard : Ingredient()\n\nopen class Sandwich : Recipe() {\n  fun action(op: Operation): Sandwich {\n    add(op)\n    return this\n  }\n  fun grill() = action(Grill())\n  fun toast() = action(Toast())\n  fun cut() = action(Cut())\n}\n\nfun sandwich(\n  fillings: Sandwich.() -> Unit\n): Sandwich {\n  val sandwich = Sandwich()\n  sandwich.add(Bread())\n  sandwich.toast()\n  sandwich.fillings()\n  sandwich.cut()\n  return sandwich\n}\n\nfun main() {\n  val pbj = sandwich {\n    add(PeanutButter())\n    add(GrapeJelly())\n  }\n  val hamAndSwiss = sandwich {\n    add(Ham())\n    add(Swiss())\n    add(Mustard())\n    grill()\n  }\n  pbj eq "[Bread, Toast, PeanutButter, " +\n    "GrapeJelly, Cut]"\n  hamAndSwiss eq "[Bread, Toast, Ham, " +\n    "Swiss, Mustard, Grill, Cut]"\n}\n')])])]),a("p",[a("code",[n._v("sandwich()")]),n._v(" captures the basic ingredients and operations to produce any "),a("code",[n._v("Sandwich")]),n._v(" (here, we assume all sandwiches are toasted, but in the exercises you’ll see how to make that optional). The "),a("code",[n._v("fillings")]),n._v(" extension lambda allows the caller to configure the "),a("code",[n._v("Sandwich")]),n._v(" in numerous different ways, but without requiring a constructor for each configuration.")]),n._v(" "),a("p",[n._v("The syntax seen in "),a("code",[n._v("main()")]),n._v(" shows how this system might be used as a DSL—the user only needs to understand the syntax of creating a "),a("code",[n._v("Sandwich")]),n._v(" by calling "),a("code",[n._v("sandwich()")]),n._v(" and providing the ingredients and operations inside the curly braces.")]),n._v(" "),a("p",[a("em",[a("strong",[n._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);