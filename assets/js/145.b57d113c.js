(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{522:function(e,t,a){"use strict";a.r(t);var n=a(44),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"property-accessors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#property-accessors"}},[e._v("#")]),e._v(" Property Accessors")]),e._v(" "),a("blockquote",[a("p",[e._v("To read a property, use its name. To assign a value to a mutable property, use the assignment operator "),a("code",[e._v("=")]),e._v(".")])]),e._v(" "),a("p",[e._v("This reads and writes the property "),a("code",[e._v("i")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// PropertyAccessors/Data.kt\npackage propertyaccessors\nimport atomictest.eq\n\nclass Data(var i: Int)\n\nfun main() {\n  val data = Data(10)\n  data.i eq 10 // Read the 'i' property\n  data.i = 20  // Write to the 'i' property\n}\n")])])]),a("p",[e._v("This appears to be straightforward access to the piece of storage named "),a("code",[e._v("i")]),e._v(". However, Kotlin calls functions to perform the read and write operations. As you expect, the default behavior of those functions reads and writes the data stored in "),a("code",[e._v("i")]),e._v(". In this atom you’ll learn to write your own "),a("em",[e._v("property accessors")]),e._v(" to customize the reading and writing actions.")]),e._v(" "),a("p",[e._v("The accessor used to get the value of a property is called a "),a("em",[e._v("getter")]),e._v(". You create a getter by defining "),a("code",[e._v("get()")]),e._v(" immediately after the property definition. The accessor used to modify a mutable property is called a "),a("em",[e._v("setter")]),e._v(". You create a setter by defining "),a("code",[e._v("set()")]),e._v(" immediately after the property definition.")]),e._v(" "),a("p",[e._v("The property accessors defined in the following example imitate the default implementations generated by Kotlin. We display additional information so you can see that the property accessors are indeed called during reads and writes. We indent "),a("code",[e._v("get()")]),e._v(" and "),a("code",[e._v("set()")]),e._v(" to visually associate them with the property, but the actual association happens because "),a("code",[e._v("get()")]),e._v(" and "),a("code",[e._v("set()")]),e._v(" are defined immediately after that property (Kotlin doesn’t care about the indentation):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// PropertyAccessors/Default.kt\npackage propertyaccessors\nimport atomictest.*\n\nclass Default {\n  var i: Int = 0\n    get() {\n      trace("get()")\n      return field       // [1]\n    }\n    set(value) {\n      trace("set($value)")\n      field = value      // [2]\n    }\n}\n\nfun main() {\n  val d = Default()\n  d.i = 2\n  trace(d.i)\n  trace eq """\n    set(2)\n    get()\n    2\n  """\n}\n')])])]),a("p",[e._v("The definition order for "),a("code",[e._v("get()")]),e._v(" and "),a("code",[e._v("set()")]),e._v(" is unimportant. You can define "),a("code",[e._v("get()")]),e._v(" without defining "),a("code",[e._v("set()")]),e._v(", and vice-versa.")]),e._v(" "),a("p",[e._v("The default behavior for a property returns its stored value from a getter and modifies it with a setter—the actions of "),a("strong",[e._v("[1]")]),e._v(" and "),a("strong",[e._v("[2]")]),e._v(". Inside the getter and setter, the stored value is manipulated indirectly using the "),a("code",[e._v("field")]),e._v(" keyword, which is only accessible within these two functions.")]),e._v(" "),a("p",[e._v("This next example uses the default implementation of the getter and adds a setter to trace changes to the property "),a("code",[e._v("n")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// PropertyAccessors/LogChanges.kt\npackage propertyaccessors\nimport atomictest.*\n\nclass LogChanges {\n  var n: Int = 0\n    set(value) {\n      trace("$field becomes $value")\n      field = value\n    }\n}\n\nfun main() {\n  val lc = LogChanges()\n  lc.n eq 0\n  lc.n = 2\n  lc.n eq 2\n  trace eq "0 becomes 2"\n}\n')])])]),a("p",[e._v("If you define a property as "),a("code",[e._v("private")]),e._v(", both accessors become "),a("code",[e._v("private")]),e._v(". You can also make the setter "),a("code",[e._v("private")]),e._v(" and the getter "),a("code",[e._v("public")]),e._v(". Then you can read the property outside the class, but only change its value inside the class:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// PropertyAccessors/Counter.kt\npackage propertyaccessors\nimport atomictest.eq\n\nclass Counter {\n  var value: Int = 0\n    private set\n  fun inc() = value++\n}\n\nfun main() {\n  val counter = Counter()\n  repeat(10) {\n    counter.inc()\n  }\n  counter.value eq 10\n}\n")])])]),a("p",[e._v("Using "),a("code",[e._v("private set")]),e._v(", we control the "),a("code",[e._v("value")]),e._v(" property so it can only be incremented by one.")]),e._v(" "),a("p",[e._v("Normal properties store their data in a field. You can also create a property that doesn’t have a field:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// PropertyAccessors/Hamsters.kt\npackage propertyaccessors\nimport atomictest.eq\n\nclass Hamster(val name: String)\n\nclass Cage(private val maxCapacity: Int) {\n  private val hamsters =\n    mutableListOf<Hamster>()\n  val capacity: Int\n    get() = maxCapacity - hamsters.size\n  val full: Boolean\n    get() = hamsters.size == maxCapacity\n  fun put(hamster: Hamster): Boolean =\n    if (full)\n      false\n    else {\n      hamsters += hamster\n      true\n    }\n  fun take(): Hamster =\n    hamsters.removeAt(0)\n}\n\nfun main() {\n  val cage = Cage(2)\n  cage.full eq false\n  cage.capacity eq 2\n  cage.put(Hamster("Alice")) eq true\n  cage.put(Hamster("Bob")) eq true\n  cage.full eq true\n  cage.capacity eq 0\n  cage.put(Hamster("Charlie")) eq false\n  cage.take()\n  cage.capacity eq 1\n}\n')])])]),a("p",[e._v("The properties "),a("code",[e._v("capacity")]),e._v(" and "),a("code",[e._v("full")]),e._v(" contain no underlying state—they are computed at the time of each access. Both "),a("code",[e._v("capacity")]),e._v(" and "),a("code",[e._v("full")]),e._v(" are similar to functions, and you can define them as such:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// PropertyAccessors/Hamsters2.kt\npackage propertyaccessors\n\nclass Cage2(private val maxCapacity: Int) {\n  private val hamsters =\n    mutableListOf<Hamster>()\n  fun capacity(): Int =\n    maxCapacity - hamsters.size\n  fun isFull(): Boolean =\n    hamsters.size == maxCapacity\n}\n")])])]),a("p",[e._v("In this case, using properties improves readability because capacity and fullness are properties of the cage. However, don’t just convert all your functions to properties—first, see how they read.")]),e._v(" "),a("ul",[a("li",[e._v("-")])]),e._v(" "),a("p",[e._v("The Kotlin style guide prefers properties over functions when the value is cheap to calculate and the property returns the same result for each invocation as long as the object state hasn’t changed.")]),e._v(" "),a("p",[e._v("Property accessors provide a kind of protection for properties. Many object-oriented languages rely on making a physical field "),a("code",[e._v("private")]),e._v(" to control access to that property. With property accessors you can add code to control or modify that access, while allowing anyone to use a property.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);