(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{489:function(e,t,a){"use strict";a.r(t);var i=a(44),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"lazy-initialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy-initialization"}},[e._v("#")]),e._v(" Lazy Initialization")]),e._v(" "),a("blockquote",[a("p",[e._v("So far, you’ve learned two ways to initialize properties.")])]),e._v(" "),a("ol",[a("li",[e._v("Store the initial value at the point of definition, or in the constructor.")]),e._v(" "),a("li",[e._v("Define a custom getter that computes the property for each access.")])]),e._v(" "),a("p",[e._v("This atom explores a third use case: costly initialization that you might not need right away, or ever. For example:")]),e._v(" "),a("ul",[a("li",[e._v("Complex and time-consuming calculations")]),e._v(" "),a("li",[e._v("Network requests")]),e._v(" "),a("li",[e._v("Database access")])]),e._v(" "),a("p",[e._v("This can produce two problems:")]),e._v(" "),a("ol",[a("li",[e._v("Long application start-up time.")]),e._v(" "),a("li",[e._v("Performing unnecessary work for a property that is never used, or that can have delayed access.")])]),e._v(" "),a("p",[e._v("This happens frequently enough that Kotlin includes a built-in solution. A "),a("code",[e._v("lazy")]),e._v(" property is initialized when it’s first used, rather than when it’s created. If we never use a "),a("code",[e._v("lazy")]),e._v(" property, it never performs that expensive initialization.")]),e._v(" "),a("p",[e._v("The concept of "),a("code",[e._v("lazy")]),e._v(" properties isn’t unique to Kotlin. Laziness can be implemented within other languages, whether or not they provide direct support. Kotlin provides a consistent, recognizable idiom for such properties using [property delegation](javascript:void(0)). With a "),a("code",[e._v("lazy")]),e._v(" property, "),a("code",[e._v("by")]),e._v(" is followed by a call to "),a("code",[e._v("lazy()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("val lazyProperty by lazy { initializer }\n")])])]),a("p",[a("code",[e._v("lazy()")]),e._v(" takes a lambda containing the initialization logic. As usual, the last expression in the lambda becomes the result, which is assigned to the property:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// LazyInitialization/LazySyntax.kt\npackage lazyinitialization\nimport atomictest.*\n\nval idle: String by lazy {\n  trace("Initializing \'idle\'")\n  "I\'m never used"\n}\n\nval helpful: String by lazy {\n  trace("Initializing \'helpful\'")\n  "I\'m helping!"\n}\n\nfun main() {\n  trace(helpful)\n  trace eq """\n    Initializing \'helpful\'\n    I\'m helping!\n  """\n}\n')])])]),a("p",[e._v("The "),a("code",[e._v("idle")]),e._v(" property isn’t initialized because it’s never accessed.")]),e._v(" "),a("p",[e._v("Notice that both "),a("code",[e._v("helpful")]),e._v(" and "),a("code",[e._v("idle")]),e._v(" are "),a("code",[e._v("val")]),e._v("s. Without "),a("code",[e._v("lazy")]),e._v(" initialization, you’d be forced to make them "),a("code",[e._v("var")]),e._v("s, producing less-reliable code.")]),e._v(" "),a("p",[e._v("We can see all the work that "),a("code",[e._v("lazy")]),e._v(" initialization does for you by implementing the behavior for an "),a("code",[e._v("Int")]),e._v(" property without it:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// LazyInitialization/LazyInt.kt\npackage lazyinitialization\nimport atomictest.*\n\nclass LazyInt(val init: () -> Int) {\n  private var helper: Int? = null\n  val value: Int\n    get() {\n      if (helper == null)\n        helper = init()\n      return helper!!\n    }\n}\n\nfun main() {\n  val later = LazyInt {\n    trace(\"Initializing 'later'\")\n    5\n  }\n  trace(\"First 'value' access:\")\n  trace(later.value)\n  trace(\"Second 'value' access:\")\n  trace(later.value)\n  trace eq \"\"\"\n    First 'value' access:\n    Initializing 'later'\n    5\n    Second 'value' access:\n    5\n  \"\"\"\n}\n")])])]),a("p",[e._v("The "),a("code",[e._v("value")]),e._v(" property doesn’t store a value, but instead has a getter that retrieves the value from the "),a("code",[e._v("helper")]),e._v(" property. This is similar to the code Kotlin generates for "),a("code",[e._v("lazy")]),e._v(".")]),e._v(" "),a("p",[e._v("Now we can compare the three ways to initialize a property—at the point of definition, using a getter, and using "),a("code",[e._v("lazy")]),e._v(" initialization:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// LazyInitialization/PropertyOptions.kt\npackage lazyinitialization\nimport atomictest.trace\n\nfun compute(i: Int): Int {\n  trace("Compute $i")\n  return i\n}\n\nobject Properties {\n  val atDefinition = compute(1)\n  val getter\n    get() = compute(2)\n  val lazyInit by lazy { compute(3) }\n  val never by lazy { compute(4) }\n}\n\nfun main() {\n  listOf(\n    Properties::atDefinition,\n    Properties::getter,\n    Properties::lazyInit\n  ).forEach {\n    trace("${it.name}:")\n    trace("${it.get()}")\n    trace("${it.get()}")\n  }\n  trace eq """\n    Compute 1\n    atDefinition:\n    1\n    1\n    getter:\n    Compute 2\n    2\n    Compute 2\n    2\n    lazyInit:\n    Compute 3\n    3\n    3\n  """\n}\n')])])]),a("ul",[a("li",[a("code",[e._v("atDefinition")]),e._v(" is initialized when you create an instance of "),a("code",[e._v("Properties")]),e._v(".")]),e._v(" "),a("li",[e._v("“Compute 1” appears before “atDefinition:” which shows that initialization happens before any accesses.")]),e._v(" "),a("li",[a("code",[e._v("getter")]),e._v(" is computed every time you access it. “Compute 2” appears twice, once for each access to the property.")]),e._v(" "),a("li",[e._v("The initialization value for "),a("code",[e._v("lazyInit")]),e._v(" is only calculated the first time it is accessed. Initialization never happens if you don’t access that property—notice that “Compute 4” never appears in the trace.")])]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);