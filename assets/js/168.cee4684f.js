(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{546:function(e,a,t){"use strict";t.r(a);var n=t(44),o=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"building-maps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#building-maps"}},[e._v("#")]),e._v(" Building Maps")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("Map")]),e._v("s are extremely useful programming tools, and there are numerous ways to construct them.")])]),e._v(" "),t("p",[e._v("To create a repeatable set of data, we use the technique shown in [Manipulating Lists](javascript:void(0)), where two "),t("code",[e._v("List")]),e._v("s are zipped and the result is used in a lambda to call a constructor, producing a "),t("code",[e._v("List<Person>")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/People.kt\npackage buildingmaps\n\ndata class Person(\n  val name: String,\n  val age: Int\n)\n\nval names = listOf("Alice", "Arthricia",\n  "Bob", "Bill", "Birdperson", "Charlie",\n  "Crocubot", "Franz", "Revolio")\n\nval ages = listOf(21, 15, 25, 25, 42, 21,\n  42, 21, 33)\n\nfun people(): List<Person> =\n  names.zip(ages) { name, age ->\n    Person(name, age)\n  }\n')])])]),t("p",[e._v("A "),t("code",[e._v("Map")]),e._v(" uses keys to provide fast access to its values. By building a "),t("code",[e._v("Map")]),e._v(" with "),t("code",[e._v("age")]),e._v(" as the key, we can quickly look up groups of people by age. The library function "),t("code",[e._v("groupBy()")]),e._v(" is one way to create such a "),t("code",[e._v("Map")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/GroupBy.kt\nimport buildingmaps.*\nimport atomictest.eq\n\nfun main() {\n  val map: Map<Int, List<Person>> =\n    people().groupBy(Person::age)\n  map[15] eq listOf(Person("Arthricia", 15))\n  map[21] eq listOf(\n    Person("Alice", 21),\n    Person("Charlie", 21),\n    Person("Franz", 21))\n  map[22] eq null\n  map[25] eq listOf(\n    Person("Bob", 25),\n    Person("Bill", 25))\n  map[33] eq listOf(Person("Revolio", 33))\n  map[42] eq listOf(\n    Person("Birdperson", 42),\n    Person("Crocubot", 42))\n}\n')])])]),t("p",[t("code",[e._v("groupBy()")]),e._v("’s parameter produces a "),t("code",[e._v("Map")]),e._v(" where each key connects to a "),t("code",[e._v("List")]),e._v(" of elements. Here, all people of the same "),t("code",[e._v("age")]),e._v(" are selected by the "),t("code",[e._v("age")]),e._v(" key.")]),e._v(" "),t("p",[e._v("You can produce the same groups using the "),t("code",[e._v("filter()")]),e._v(" function, but "),t("code",[e._v("groupBy()")]),e._v(" is preferable because it only performs the grouping once. With "),t("code",[e._v("filter()")]),e._v(" you must repeat the grouping for each new key:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/GroupByVsFilter.kt\nimport buildingmaps.*\nimport atomictest.eq\n\nfun main() {\n  val groups =\n    people().groupBy { it.name.first() }\n  // groupBy() produces map-speed access:\n  groups[\'A\'] eq listOf(Person("Alice", 21),\n    Person("Arthricia", 15))\n  groups[\'Z\'] eq null\n\n  // Must repeat filter() for each character:\n  people().filter {\n    it.name.first() == \'A\'\n  } eq listOf(Person("Alice", 21),\n    Person("Arthricia", 15))\n  people().filter {\n    it.name.first() == \'F\'\n  } eq listOf(Person("Franz", 21))\n\n  people().partition {\n    it.name.first() == \'A\'\n  } eq Pair(\n    listOf(Person("Alice", 21),\n      Person("Arthricia", 15)),\n    listOf(Person("Bob", 25),\n      Person("Bill", 25),\n      Person("Birdperson", 42),\n      Person("Charlie", 21),\n      Person("Crocubot", 42),\n      Person("Franz", 21),\n      Person("Revolio", 33)))\n}\n')])])]),t("p",[e._v("Here, "),t("code",[e._v("groupBy()")]),e._v(" groups "),t("code",[e._v("people()")]),e._v(" by their first character, selected by "),t("code",[e._v("first()")]),e._v(". We can also use "),t("code",[e._v("filter()")]),e._v(" to produce the same result by repeating the lambda code for each character.")]),e._v(" "),t("p",[e._v("If you only need two groups, the "),t("code",[e._v("partition()")]),e._v(" function is more direct because it divides the contents into two lists based on a predicate. "),t("code",[e._v("groupBy()")]),e._v(" is appropriate when you need more than two resulting groups.")]),e._v(" "),t("p",[t("code",[e._v("associateWith()")]),e._v(" allows you to take a list of keys and build a "),t("code",[e._v("Map")]),e._v(" by associating each of these keys with a value created by its parameter (here, the lambda):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/AssociateWith.kt\nimport buildingmaps.*\nimport atomictest.eq\n\nfun main() {\n  val map: Map<Person, String> =\n    people().associateWith { it.name }\n  map eq mapOf(\n    Person("Alice", 21) to "Alice",\n    Person("Arthricia", 15) to "Arthricia",\n    Person("Bob", 25) to "Bob",\n    Person("Bill", 25) to "Bill",\n    Person("Birdperson", 42) to "Birdperson",\n    Person("Charlie", 21) to "Charlie",\n    Person("Crocubot", 42) to "Crocubot",\n    Person("Franz", 21) to "Franz",\n    Person("Revolio", 33) to "Revolio")\n}\n')])])]),t("p",[t("code",[e._v("associateBy()")]),e._v(" reverses the order of association produced by "),t("code",[e._v("associateWith()")]),e._v("—the selector (the lambda in the following example) becomes the key:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/AssociateBy.kt\nimport buildingmaps.*\nimport atomictest.eq\n\nfun main() {\n  val map: Map<String, Person> =\n    people().associateBy { it.name }\n  map eq mapOf(\n    "Alice" to Person("Alice", 21),\n    "Arthricia" to Person("Arthricia", 15),\n    "Bob" to Person("Bob", 25),\n    "Bill" to Person("Bill", 25),\n    "Birdperson" to Person("Birdperson", 42),\n    "Charlie" to Person("Charlie", 21),\n    "Crocubot" to Person("Crocubot", 42),\n    "Franz" to Person("Franz", 21),\n    "Revolio" to Person("Revolio", 33))\n}\n')])])]),t("p",[t("code",[e._v("associateBy()")]),e._v(" must be used with a unique selection key and returns a "),t("code",[e._v("Map")]),e._v(" that pairs each unique key to the single element selected by that key.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/AssociateByUnique.kt\nimport buildingmaps.*\nimport atomictest.eq\n\nfun main() {\n  // associateBy() fails when the key isn\'t\n  // unique -- values disappear:\n  val ages = people().associateBy { it.age }\n  ages eq mapOf(\n    21 to Person("Franz", 21),\n    15 to Person("Arthricia", 15),\n    25 to Person("Bill", 25),\n    42 to Person("Crocubot", 42),\n    33 to Person("Revolio", 33))\n}\n')])])]),t("p",[e._v("If multiple values are selected by the predicate, as in "),t("code",[e._v("ages")]),e._v(", only the last one appears in the generated "),t("code",[e._v("Map")]),e._v(".")]),e._v(" "),t("p",[t("code",[e._v("getOrElse()")]),e._v(" tries to look up a value in a "),t("code",[e._v("Map")]),e._v(". Its associated lambda computes a default value when a key is not present. Because it’s a lambda, we compute the default "),t("code",[e._v("key")]),e._v(" only when necessary:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/GetOrPut.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf(1 to "one", 2 to "two")\n\n  map.getOrElse(0) { "zero" } eq "zero"\n\n  val mutableMap = map.toMutableMap()\n  mutableMap.getOrPut(0) { "zero" } eq\n    "zero"\n  mutableMap eq "{1=one, 2=two, 0=zero}"\n}\n')])])]),t("p",[t("code",[e._v("getOrPut()")]),e._v(" works on a "),t("code",[e._v("MutableMap")]),e._v(". If a key is present it simply returns the associated value. If the key isn’t found, it computes the value, puts it into the map and returns that value.")]),e._v(" "),t("p",[e._v("Many "),t("code",[e._v("Map")]),e._v(" operations duplicate ones in "),t("code",[e._v("List")]),e._v(". For example, you can "),t("code",[e._v("filter()")]),e._v(" or "),t("code",[e._v("map()")]),e._v(" the contents of a "),t("code",[e._v("Map")]),e._v(". You can filter keys and values separately:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/FilterMap.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf(1 to "one",\n    2 to "two", 3 to "three", 4 to "four")\n\n  map.filterKeys { it % 2 == 1 } eq\n    "{1=one, 3=three}"\n\n  map.filterValues { it.contains(\'o\') } eq\n    "{1=one, 2=two, 4=four}"\n\n  map.filter { entry ->\n    entry.key % 2 == 1 &&\n      entry.value.contains(\'o\')\n  } eq "{1=one}"\n}\n')])])]),t("p",[e._v("All three functions "),t("code",[e._v("filter()")]),e._v(", "),t("code",[e._v("filterKeys()")]),e._v(" and "),t("code",[e._v("filterValues()")]),e._v(" produce a new map containing only the elements that satisfy the predicate. "),t("code",[e._v("filterKeys()")]),e._v(" applies its predicate to the keys, and "),t("code",[e._v("filterValues()")]),e._v(" applies its predicate to the values.")]),e._v(" "),t("h3",{attrs:{id:"applying-operations-to-maps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#applying-operations-to-maps"}},[e._v("#")]),e._v(" Applying Operations to Maps")]),e._v(" "),t("p",[e._v("To "),t("code",[e._v("map()")]),e._v(" a "),t("code",[e._v("Map")]),e._v(" sounds like a tautology, like saying “salt is salty.” The word "),t("em",[e._v("map")]),e._v(" represents two distinct ideas:")]),e._v(" "),t("ul",[t("li",[e._v("Transforming a collection")]),e._v(" "),t("li",[e._v("The key-value data structure")])]),e._v(" "),t("p",[e._v("In many programming languages, the word "),t("em",[e._v("map")]),e._v(" is used for both concepts. For clarity, we say "),t("em",[e._v("transform a map")]),e._v(" when applying "),t("code",[e._v("map()")]),e._v(" to a "),t("code",[e._v("Map")]),e._v(".")]),e._v(" "),t("p",[e._v("Here we demonstrate "),t("code",[e._v("map()")]),e._v(", "),t("code",[e._v("mapKeys()")]),e._v(" and "),t("code",[e._v("mapValues()")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/TransformingMap.kt\nimport atomictest.eq\n\nfun main() {\n  val even = mapOf(2 to "two", 4 to "four")\n  even.map {                            // [1]\n    "${it.key}=${it.value}"\n  } eq listOf("2=two", "4=four")\n\n  even.map { (key, value) ->            // [2]\n    "$key=$value"\n  } eq listOf("2=two", "4=four")\n\n  even.mapKeys { (num, _) -> -num }     // [3]\n    .mapValues { (_, str) -> "minus $str" } eq\n    mapOf(-2 to "minus two",\n      -4 to "minus four")\n\n  even.map { (key, value) ->\n    -key to "minus $value"\n  }.toMap() eq mapOf(-2 to "minus two", // [4]\n    -4 to "minus four")\n}\n')])])]),t("ul",[t("li",[t("strong",[e._v("[1]")]),e._v(" Here, "),t("code",[e._v("map()")]),e._v(" takes a predicate with a "),t("code",[e._v("Map.Entry")]),e._v(" argument. We access its contents as "),t("code",[e._v("it.key")]),e._v(" and "),t("code",[e._v("it.value")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[2]")]),e._v(" You can also use a [destructuring declaration](javascript:void(0)) to place the entry contents into "),t("code",[e._v("key")]),e._v(" and "),t("code",[e._v("value")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("[3]")]),e._v(" If a parameter isn’t used, an underscore ("),t("code",[e._v("_")]),e._v(") avoids compiler complaints. "),t("code",[e._v("mapKeys()")]),e._v(" and "),t("code",[e._v("mapValues()")]),e._v(" return a new map, with all keys or values transformed accordingly.")]),e._v(" "),t("li",[t("strong",[e._v("[4]")]),e._v(", "),t("code",[e._v("map()")]),e._v(" returns a list of pairs, so to produce a "),t("code",[e._v("Map")]),e._v(" we use the explicit conversion "),t("code",[e._v("toMap()")]),e._v(".")])]),e._v(" "),t("p",[e._v("Functions like "),t("code",[e._v("any()")]),e._v(" and "),t("code",[e._v("all()")]),e._v(" can also be applied to "),t("code",[e._v("Map")]),e._v("s:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// BuildingMaps/SimilarOperation.kt\nimport atomictest.eq\n\nfun main() {\n  val map = mapOf(1 to "one",\n    -2 to "minus two")\n  map.any { (key, _) -> key < 0 } eq true\n  map.all { (key, _) -> key < 0 } eq false\n  map.maxByOrNull { it.key }?.value eq "one"\n}\n')])])]),t("p",[t("code",[e._v("any()")]),e._v(" checks whether any of the entries in a "),t("code",[e._v("Map")]),e._v(" satisfy the given predicate, while "),t("code",[e._v("all()")]),e._v(" is "),t("code",[e._v("true")]),e._v(" only if all entries in the "),t("code",[e._v("Map")]),e._v(" satisfy the predicate.")]),e._v(" "),t("p",[t("code",[e._v("maxByOrNull()")]),e._v(" finds the maximum entry based on the given criteria. There may not be a maximum entry, so the result is nullable.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);a.default=o.exports}}]);