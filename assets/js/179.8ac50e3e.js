(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{560:function(e,t,o){"use strict";o.r(t);var n=o(44),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"composition"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#composition"}},[e._v("#")]),e._v(" Composition")]),e._v(" "),o("blockquote",[o("p",[e._v("One of the most compelling arguments for object-oriented programming is code reuse.")])]),e._v(" "),o("p",[e._v("You may first think of “reuse” as “copying code.” Copying seems like an easy solution, but it doesn’t work very well. As time passes, your needs evolve. Applying changes to code that’s been copied is a maintenance nightmare. Did you find all the copies? Did you make the changes the same way for each copy? Reused code can be changed in just one place.")]),e._v(" "),o("p",[e._v("In object-oriented programming you reuse code by creating new classes, but instead of creating them from scratch, you use existing classes that someone has already built and debugged. The trick is to use the classes without soiling the existing code.")]),e._v(" "),o("p",[e._v("Inheritance is one way to achieve this. Inheritance creates a new class as a "),o("em",[e._v("type of")]),e._v(" an existing class. You add code to the form of the existing class without modifying the original. Inheritance is a cornerstone of object-oriented programming.")]),e._v(" "),o("p",[e._v("You can also choose a more straightforward approach, by creating objects of existing classes "),o("em",[e._v("inside")]),e._v(" your new class. This is called "),o("em",[e._v("composition")]),e._v(", because the new class is composed of objects of existing classes. You’re reusing the "),o("em",[e._v("functionality")]),e._v(" of the code, not its form.")]),e._v(" "),o("p",[e._v("Composition is used frequently in this book. Composition is often overlooked because it seems so simple—you just put an object inside a class.")]),e._v(" "),o("p",[e._v("Composition is a "),o("em",[e._v("has-a")]),e._v(" relationship. “A house "),o("em",[e._v("is a")]),e._v(" building and "),o("em",[e._v("has a")]),e._v(" kitchen” can be expressed like this:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// Composition/House1.kt\npackage composition1\n\ninterface Building\ninterface Kitchen\n\ninterface House: Building {\n  val kitchen: Kitchen\n}\n")])])]),o("p",[e._v("Inheritance describes an "),o("em",[e._v("is-a")]),e._v(" relationship, and it’s often helpful to read the description aloud: “A house is a building.” That sounds right, doesn’t it? When the is-a relationship makes sense, inheritance usually makes sense.")]),e._v(" "),o("p",[e._v("If your house has two kitchens, composition yields an easy solution:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// Composition/House2.kt\npackage composition2\n\ninterface Building\ninterface Kitchen\n\ninterface House: Building {\n  val kitchen1: Kitchen\n  val kitchen2: Kitchen\n}\n")])])]),o("p",[e._v("To allow any number of kitchens, use composition with a collection:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// Composition/House3.kt\npackage composition3\n\ninterface Building\ninterface Kitchen\n\ninterface House: Building {\n  val kitchens: List<Kitchen>\n}\n")])])]),o("p",[e._v("We spend time and effort understanding inheritance because it’s more complex, and that complexity might give the impression that it’s somehow more important. On the contrary:")]),e._v(" "),o("blockquote",[o("p",[o("em",[e._v("Prefer composition to inheritance.")])])]),e._v(" "),o("p",[e._v("Composition produces simpler designs and implementations. This doesn’t mean you should avoid inheritance. It’s just that we tend to get bound up in more complicated relationships. The maxim "),o("em",[e._v("prefer composition to inheritance")]),e._v(" is a reminder to step back, look at your design, and wonder whether you can simplify it with composition. The ultimate goal is to properly apply your tools and produce a good design.")]),e._v(" "),o("p",[e._v("Composition appears trivial, but is powerful. When a class grows and becomes responsible for different unrelated things, composition helps pull them apart. Use composition to simplify the complicated logic of a class.")]),e._v(" "),o("h3",{attrs:{id:"choosing-between-composition-and-inheritance"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#choosing-between-composition-and-inheritance"}},[e._v("#")]),e._v(" Choosing Between Composition and Inheritance")]),e._v(" "),o("p",[e._v("Both composition and inheritance put subobjects inside your new class—composition has explicit subobjects while inheritance has implicit subjobjects. When do you choose one over the other?")]),e._v(" "),o("p",[e._v("Composition provides the functionality of an existing class, but not its interface. You embed an object to use its features in your new class, but the user sees the interface you’ve defined for that new class rather than the interface of the embedded object. To hide the object completely, embed it privately:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// Composition/Embedding.kt\npackage composition\n\nclass Features {\n  fun f1() = "feature1"\n  fun f2() = "feature2"\n}\n\nclass Form {\n  private val features = Features()\n  fun operation1() =\n    features.f2() + features.f1()\n  fun operation2() =\n    features.f1() + features.f2()\n}\n')])])]),o("p",[e._v("The "),o("code",[e._v("Features")]),e._v(" class provides implementations for the operations of "),o("code",[e._v("Form")]),e._v(", but the client programmer who uses "),o("code",[e._v("Form")]),e._v(" has no access to "),o("code",[e._v("features")]),e._v("—indeed, the user is effectively unaware of "),o("em",[e._v("how")]),e._v(" "),o("code",[e._v("Form")]),e._v(" is implemented. This means that if you find a better way to implement "),o("code",[e._v("Form")]),e._v(", you can remove "),o("code",[e._v("features")]),e._v(" and change to the new approach without any impact on code that calls "),o("code",[e._v("Form")]),e._v(".")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("Form")]),e._v(" inherited "),o("code",[e._v("Features")]),e._v(", the client programmer could expect to upcast "),o("code",[e._v("Form")]),e._v(" to "),o("code",[e._v("Features")]),e._v(". The inheritance relationship is then part of "),o("code",[e._v("Form")]),e._v("—the connection is explicit. If you change this, you’ll break code that relies upon that connection.")]),e._v(" "),o("p",[e._v("Sometimes it makes sense to allow the class user to directly access the composition of your new class; that is, to make the member objects public. This is relatively safe, assuming the member objects use appropriate implementation hiding. For some systems, this approach can make the interface easier to understand. Consider a "),o("code",[e._v("Car")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// Composition/Car.kt\npackage composition\nimport atomictest.*\n\nclass Engine {\n  fun start() = trace("Engine start")\n  fun stop() = trace("Engine stop")\n}\n\nclass Wheel {\n  fun inflate(psi: Int) =\n    trace("Wheel inflate($psi)")\n}\n\nclass Window(val side: String) {\n  fun rollUp() =\n    trace("$side Window roll up")\n  fun rollDown() =\n    trace("$side Window roll down")\n}\n\nclass Door(val side: String) {\n  val window = Window(side)\n  fun open() = trace("$side Door open")\n  fun close() = trace("$side Door close")\n}\n\nclass Car {\n  val engine = Engine()\n  val wheel = List(4) { Wheel() }\n  // Two door:\n  val leftDoor = Door("left")\n  val rightDoor = Door("right")\n}\n\nfun main() {\n  val car = Car()\n  car.leftDoor.open()\n  car.rightDoor.window.rollUp()\n  car.wheel[0].inflate(72)\n  car.engine.start()\n  trace eq """\n    left Door open\n    right Window roll up\n    Wheel inflate(72)\n    Engine start\n  """\n}\n')])])]),o("p",[e._v("The composition of a "),o("code",[e._v("Car")]),e._v(" is part of the analysis of the problem, and not simply part of the underlying implementation. This assists the client programmer’s understanding of how to use the class and requires less code complexity for the creator of the class.")]),e._v(" "),o("p",[e._v("When you inherit, you create a custom version of an existing class. This takes a general-purpose class and specializes it for a particular need. In this example, it would make no sense to compose a "),o("code",[e._v("Car")]),e._v(" using an object of a "),o("code",[e._v("Vehicle")]),e._v(" class—a "),o("code",[e._v("Car")]),e._v(" doesn’t "),o("em",[e._v("contain")]),e._v(" a "),o("code",[e._v("Vehicle")]),e._v(", it "),o("em",[e._v("is")]),e._v(" a "),o("code",[e._v("Vehicle")]),e._v(". The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition.")]),e._v(" "),o("p",[e._v("The cleverness of polymorphism can make it can seem that everything ought to be inherited. This will burden your designs. In fact, if you choose inheritance first when you’re using an existing class to build a new class, things can become needlessly complicated. A better approach is to try composition first, especially when it’s not obvious which approach works best.")]),e._v(" "),o("p",[o("em",[o("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);