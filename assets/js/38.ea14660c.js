(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{409:function(e,t,n){"use strict";n.r(t);var a=n(44),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"number-types"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#number-types"}},[e._v("#")]),e._v(" Number Types")]),e._v(" "),n("blockquote",[n("p",[e._v("Different types of numbers are stored in different ways.")])]),e._v(" "),n("p",[e._v("If you create an identifier and assign an integer value to it, Kotlin infers the "),n("code",[e._v("Int")]),e._v(" type:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/InferInt.kt\n\nfun main() {\n  val million = 1_000_000  // Infers Int\n  println(million)\n}\n/* Output:\n1000000\n*/\n")])])]),n("p",[e._v("For readability, Kotlin allows underscores within numerical values.")]),e._v(" "),n("p",[e._v("The basic mathematical operators for numbers are the ones available in most programming languages: addition ("),n("code",[e._v("+")]),e._v("), subtraction ("),n("code",[e._v("-")]),e._v("), division ("),n("code",[e._v("/")]),e._v("), multiplication ("),n("code",[e._v("*")]),e._v(") and modulus ("),n("code",[e._v("%")]),e._v("), which produces the remainder from integer division:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/Modulus.kt\n\nfun main() {\n  val numerator: Int = 19\n  val denominator: Int = 10\n  println(numerator % denominator)\n}\n/* Output:\n9\n*/\n")])])]),n("p",[e._v("Integer division truncates its result:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/IntDivisionTruncates.kt\n\nfun main() {\n  val numerator: Int = 19\n  val denominator: Int = 10\n  println(numerator / denominator)\n}\n/* Output:\n1\n*/\n")])])]),n("p",[e._v("If the operation had rounded the result, the output would be "),n("code",[e._v("2")]),e._v(".")]),e._v(" "),n("p",[e._v("The order of operations follows basic arithmetic:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/OpOrder.kt\n\nfun main() {\n  println(45 + 5 * 6)\n}\n/* Output:\n75\n*/\n")])])]),n("p",[e._v("The multiplication operation "),n("code",[e._v("5 * 6")]),e._v(" is performed first, followed by the addition "),n("code",[e._v("45 + 30")]),e._v(".")]),e._v(" "),n("p",[e._v("If you want "),n("code",[e._v("45 + 5")]),e._v(" to happen first, use parentheses:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/OpOrderParens.kt\n\nfun main() {\n  println((45 + 5) * 6)\n}\n/* Output:\n300\n*/\n")])])]),n("p",[e._v("Now let’s calculate "),n("em",[e._v("body mass index")]),e._v(" (BMI), which is weight in kilograms divided by the square of the height in meters. If you have a BMI of less than "),n("code",[e._v("18.5")]),e._v(", you are underweight. Between "),n("code",[e._v("18.5")]),e._v(" and "),n("code",[e._v("24.9")]),e._v(" is normal weight. BMI of "),n("code",[e._v("25")]),e._v(" and higher is overweight. This example also shows the preferred formatting style when you can’t fit the function’s parameters on a single line:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NumberTypes/BMIMetric.kt\n\nfun bmiMetric(\n  weight: Double,\n  height: Double\n): String {\n  val bmi = weight / (height * height)  // [1]\n  return if (bmi < 18.5) "Underweight"\n    else if (bmi < 25) "Normal weight"\n    else "Overweight"\n}\n\nfun main() {\n  val weight = 72.57 // 160 lbs\n  val height = 1.727 // 68 inches\n  val status = bmiMetric(weight, height)\n  println(status)\n}\n/* Output:\nNormal weight\n*/\n')])])]),n("ul",[n("li",[n("strong",[e._v("[1]")]),e._v(" If you remove the parentheses, you divide "),n("code",[e._v("weight")]),e._v(" by "),n("code",[e._v("height")]),e._v(" then multiply that result by "),n("code",[e._v("height")]),e._v(". That’s a much larger number, and the wrong answer.")])]),e._v(" "),n("p",[n("code",[e._v("bmiMetric()")]),e._v(" uses "),n("code",[e._v("Double")]),e._v("s for the weight and height. A "),n("code",[e._v("Double")]),e._v(" holds very large and very small floating-point numbers.")]),e._v(" "),n("p",[e._v("Here’s a version using English units, represented by "),n("code",[e._v("Int")]),e._v(" parameters:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NumberTypes/BMIEnglish.kt\n\nfun bmiEnglish(\n  weight: Int,\n  height: Int\n): String {\n  val bmi =\n    weight / (height * height) * 703.07 // [1]\n  return if (bmi < 18.5) "Underweight"\n    else if (bmi < 25) "Normal weight"\n    else "Overweight"\n}\n\nfun main() {\n  val weight = 160\n  val height = 68\n  val status = bmiEnglish(weight, height)\n  println(status)\n}\n/* Output:\nUnderweight\n*/\n')])])]),n("p",[e._v("Why does the result differ from "),n("code",[e._v("bmiMetric()")]),e._v(", which uses "),n("code",[e._v("Double")]),e._v("s? When you divide an integer by another integer, Kotlin produces an integer result. The standard way to deal with the remainder during integer division is "),n("em",[e._v("truncation")]),e._v(", meaning “chop it off and throw it away” (there’s no rounding). So if you divide "),n("code",[e._v("5")]),e._v(" by "),n("code",[e._v("2")]),e._v(" you get "),n("code",[e._v("2")]),e._v(", and "),n("code",[e._v("7/10")]),e._v(" is zero. When Kotlin calculates "),n("code",[e._v("bmi")]),e._v(" in expression "),n("strong",[e._v("[1]")]),e._v(", it divides "),n("code",[e._v("160")]),e._v(" by "),n("code",[e._v("68 * 68")]),e._v(" and gets zero. It then multiplies zero by "),n("code",[e._v("703.07")]),e._v(" to get zero.")]),e._v(" "),n("p",[e._v("To avoid this problem, move "),n("code",[e._v("703.07")]),e._v(" to the front of the calculation. The calculations are then forced to be "),n("code",[e._v("Double")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("val bmi = 703.07 * weight / (height * height)\n")])])]),n("p",[e._v("The "),n("code",[e._v("Double")]),e._v(" parameters in "),n("code",[e._v("bmiMetric()")]),e._v(" prevent this problem. Convert computations to the desired type as early as possible to preserve accuracy.")]),e._v(" "),n("p",[e._v("All programming languages have limits to what they can store within an integer. Kotlin’s "),n("code",[e._v("Int")]),e._v(" type can take values between -231 and +231-1, a constraint of the "),n("code",[e._v("Int")]),e._v(" 32-bit representation. If you sum or multiply two "),n("code",[e._v("Int")]),e._v("s that are big enough, you’ll overflow the result:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/IntegerOverflow.kt\n\nfun main() {\n  val i: Int = Int.MAX_VALUE\n  println(i + i)\n}\n/* Output:\n-2\n*/\n")])])]),n("p",[n("code",[e._v("Int.MAX_VALUE")]),e._v(" is a predefined value which is the largest number an "),n("code",[e._v("Int")]),e._v(" can hold.")]),e._v(" "),n("p",[e._v("The overflow produces a result that is clearly incorrect, as it is both negative and much smaller than we expect. Kotlin issues a warning whenever it detects a potential overflow.")]),e._v(" "),n("p",[e._v("Preventing overflow is your responsibility as a developer. Kotlin can’t always detect overflow during compilation, and it doesn’t prevent overflow because that would produce an unacceptable performance impact.")]),e._v(" "),n("p",[e._v("If your program contains large numbers, you can use "),n("code",[e._v("Long")]),e._v("s, which accommodate values from -263 to +263-1. To define a "),n("code",[e._v("val")]),e._v(" of type "),n("code",[e._v("Long")]),e._v(", you can specify the type explicitly or put "),n("code",[e._v("L")]),e._v(" at the end of a numeric literal, which tells Kotlin to treat that value as a "),n("code",[e._v("Long")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// NumberTypes/LongConstants.kt\n\nfun main() {\n  val i = 0          // Infers Int\n  val l1 = 0L        // L creates Long\n  val l2: Long = 0   // Explicit type\n  println("$l1 $l2")\n}\n/* Output:\n0 0\n*/\n')])])]),n("p",[e._v("By changing to "),n("code",[e._v("Long")]),e._v("s we prevent the overflow in "),n("code",[e._v("IntegerOverflow.kt")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/UsingLongs.kt\n\nfun main() {\n  val i = Int.MAX_VALUE\n  println(0L + i + i)              // [1]\n  println(1_000_000 * 1_000_000L)  // [2]\n}\n/* Output:\n4294967294\n1000000000000\n*/\n")])])]),n("p",[e._v("Using a numeric literal in both "),n("strong",[e._v("[1]")]),e._v(" and "),n("strong",[e._v("[2]")]),e._v(" forces "),n("code",[e._v("Long")]),e._v(" calculations, and also produces a result of type "),n("code",[e._v("Long")]),e._v(". The location where the "),n("code",[e._v("L")]),e._v(" appears is unimportant. If one of the values is "),n("code",[e._v("Long")]),e._v(", the resulting expression is "),n("code",[e._v("Long")]),e._v(".")]),e._v(" "),n("p",[e._v("Although they can hold much larger values than "),n("code",[e._v("Int")]),e._v("s, "),n("code",[e._v("Long")]),e._v("s still have size limitations:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// NumberTypes/BiggestLong.kt\n\nfun main() {\n  println(Long.MAX_VALUE)\n}\n/* Output:\n9223372036854775807\n*/\n")])])]),n("p",[n("code",[e._v("Long.MAX_VALUE")]),e._v(" is the largest value a "),n("code",[e._v("Long")]),e._v(" can hold.")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);