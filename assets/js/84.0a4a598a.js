(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{457:function(e,n,t){"use strict";t.r(n);var a=t(44),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"interfaces"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interfaces"}},[e._v("#")]),e._v(" Interfaces")]),e._v(" "),t("blockquote",[t("p",[e._v("An "),t("em",[e._v("interface")]),e._v(" describes the concept of a type. It is a prototype for all classes that "),t("em",[e._v("implement")]),e._v(" the interface.")])]),e._v(" "),t("p",[e._v("It describes "),t("em",[e._v("what")]),e._v(" a class should do, but not "),t("em",[e._v("how")]),e._v(" it should do it. An interface provides a form, but generally no implementation. It specifies an object’s actions without detailing how those actions are performed. The interface describes the mission or goal of an entity, versus a class that contains implementation details.")]),e._v(" "),t("p",[e._v("One dictionary definition says that an interface is “The place at which independent and often unrelated systems meet and act on or communicate with each other.” Thus, an interface is a means of communication between different parts of a system.")]),e._v(" "),t("p",[e._v("An "),t("em",[e._v("Application Programming Interface")]),e._v(" (API) is a set of clearly defined communication paths between various software components. In object-oriented programming, the API of an object is the set of public members it uses to interact with other objects.")]),e._v(" "),t("p",[e._v("Code using a particular interface only knows what functions can be called for that interface. The interface establishes a “protocol” between classes. (Some object-oriented languages have a keyword called "),t("em",[e._v("protocol")]),e._v(" to do the same thing.)")]),e._v(" "),t("p",[e._v("To create an interface, use the "),t("code",[e._v("interface")]),e._v(" keyword instead of the "),t("code",[e._v("class")]),e._v(" keyword. When defining a class that implements an interface, follow the class name with a "),t("code",[e._v(":")]),e._v(" (colon) and the name of the interface:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Interfaces/Computer.kt\npackage interfaces\nimport atomictest.*\n\ninterface Computer {\n  fun prompt(): String\n  fun calculateAnswer(): Int\n}\n\nclass Desktop : Computer {\n  override fun prompt() = "Hello!"\n  override fun calculateAnswer() = 11\n}\n\nclass DeepThought : Computer {\n  override fun prompt() = "Thinking..."\n  override fun calculateAnswer() = 42\n}\n\nclass Quantum : Computer {\n  override fun prompt() = "Probably..."\n  override fun calculateAnswer() = -1\n}\n\nfun main() {\n  val computers = listOf(\n    Desktop(), DeepThought(), Quantum()\n  )\n  computers.map { it.calculateAnswer() } eq\n    "[11, 42, -1]"\n  computers.map { it.prompt() } eq\n    "[Hello!, Thinking..., Probably...]"\n}\n')])])]),t("p",[t("code",[e._v("Computer")]),e._v(" "),t("em",[e._v("declares")]),e._v(" "),t("code",[e._v("prompt()")]),e._v(" and "),t("code",[e._v("calculateAnswer()")]),e._v(" but provides no implementations. A class that implements the interface must provide bodies for all the declared functions, making those functions "),t("em",[e._v("concrete")]),e._v(". In "),t("code",[e._v("main()")]),e._v(" you see that different implementations of an interface express different behaviors via their function definitions.")]),e._v(" "),t("p",[e._v("When implementing a member of an interface, you must use the "),t("code",[e._v("override")]),e._v(" modifier. "),t("code",[e._v("override")]),e._v(" tells Kotlin you are intentionally using the same name that appears in the interface (or base class)—that is, you aren’t accidentally overriding.")]),e._v(" "),t("p",[e._v("An interface can declare properties. These must be overridden in all classes implementing that interface:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Interfaces/PlayerInterface.kt\npackage interfaces\nimport atomictest.eq\n\ninterface Player {\n  val symbol: Char\n}\n\nclass Food : Player {\n  override val symbol = '.'\n}\n\nclass Robot : Player {\n  override val symbol get() = 'R'\n}\n\nclass Wall(override val symbol: Char) : Player\n\nfun main() {\n  listOf(Food(), Robot(), Wall('|')).map {\n    it.symbol\n  } eq \"[., R, |]\"\n}\n")])])]),t("p",[e._v("Each subclass overrides the "),t("code",[e._v("symbol")]),e._v(" property in a different way:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Food")]),e._v(" directly replaces the "),t("code",[e._v("symbol")]),e._v(" value.")]),e._v(" "),t("li",[t("code",[e._v("Robot")]),e._v(" has a custom getter that returns the value (see [Property Accessors](javascript:void(0))).")]),e._v(" "),t("li",[t("code",[e._v("Wall")]),e._v(" overrides "),t("code",[e._v("symbol")]),e._v(" inside the constructor argument list (see [Constructors](javascript:void(0)))")])]),e._v(" "),t("p",[e._v("An enumeration can implement an "),t("code",[e._v("interface")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Interfaces/Hotness.kt\npackage interfaces\nimport atomictest.*\n\ninterface Hotness {\n  fun feedback(): String\n}\n\nenum class SpiceLevel : Hotness {\n  Mild {\n    override fun feedback() =\n      "It adds flavor!"\n  },\n  Medium {\n    override fun feedback() =\n      "Is it warm in here?"\n  },\n  Hot {\n    override fun feedback() =\n      "I\'m suddenly sweating a lot."\n  },\n  Flaming {\n    override fun feedback() =\n      "I\'m in pain. I am suffering."\n  }\n}\n\nfun main() {\n  SpiceLevel.values().map { it.feedback() } eq\n    "[It adds flavor!, " +\n    "Is it warm in here?, " +\n    "I\'m suddenly sweating a lot., " +\n    "I\'m in pain. I am suffering.]"\n}\n')])])]),t("p",[e._v("The compiler ensures that each "),t("code",[e._v("enum")]),e._v(" element provides a definition for "),t("code",[e._v("feedback()")]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"sam-conversions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sam-conversions"}},[e._v("#")]),e._v(" SAM Conversions")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("Single Abstract Method")]),e._v(" (SAM) interface comes from Java, where they call member functions “methods.” Kotlin has a special syntax for defining SAM interfaces: "),t("code",[e._v("fun interface")]),e._v(". Here we show SAM interfaces with different parameter lists:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Interfaces/SAM.kt\npackage interfaces\n\nfun interface ZeroArg {\n  fun f(): Int\n}\n\nfun interface OneArg {\n  fun g(n: Int): Int\n}\n\nfun interface TwoArg {\n  fun h(i: Int, j: Int): Int\n}\n")])])]),t("p",[e._v("When you say "),t("code",[e._v("fun interface")]),e._v(", the compiler ensures there is only a single member function.")]),e._v(" "),t("p",[e._v("You can implement a SAM interface in the ordinary verbose way, or by passing it a lambda; the latter is called a "),t("em",[e._v("SAM conversion")]),e._v(". In a SAM conversion, the lambda becomes the implementation for the single method in the interface. Here we show both ways to implement the three interfaces:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Interfaces/SAMImplementation.kt\npackage interfaces\nimport atomictest.eq\n\nclass VerboseZero : ZeroArg {\n  override fun f() = 11\n}\n\nval verboseZero = VerboseZero()\n\nval samZero = ZeroArg { 11 }\n\nclass VerboseOne : OneArg {\n  override fun g(n: Int) = n + 47\n}\n\nval verboseOne = VerboseOne()\n\nval samOne = OneArg { it + 47 }\n\nclass VerboseTwo : TwoArg {\n  override fun h(i: Int, j: Int) = i + j\n}\n\nval verboseTwo = VerboseTwo()\n\nval samTwo =  TwoArg { i, j -> i + j }\n\nfun main() {\n  verboseZero.f() eq 11\n  samZero.f() eq 11\n  verboseOne.g(92) eq 139\n  samOne.g(92) eq 139\n  verboseTwo.h(11, 47) eq 58\n  samTwo.h(11, 47) eq 58\n}\n")])])]),t("p",[e._v("Comparing the “verbose” implementations to the “sam” implementations you can see that SAM conversions produce much more succinct syntax for a commonly-used idiom, and you aren’t forced to define a class to create a single object.")]),e._v(" "),t("p",[e._v("You can pass a lambda where a SAM interface is expected, without first wrapping it into an object:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Interfaces/SAMConversion.kt\npackage interfaces\nimport atomictest.trace\n\nfun interface Action {\n  fun act()\n}\n\nfun delayAction(action: Action) {\n  trace("Delaying...")\n  action.act()\n}\n\nfun main() {\n  delayAction { trace("Hey!") }\n  trace eq "Delaying... Hey!"\n}\n')])])]),t("p",[e._v("In "),t("code",[e._v("main()")]),e._v(" we pass a lambda instead of an object that implements the "),t("code",[e._v("Action")]),e._v(" "),t("code",[e._v("interface")]),e._v(". Kotlin automatically creates an "),t("code",[e._v("Action")]),e._v(" object from this lambda.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);