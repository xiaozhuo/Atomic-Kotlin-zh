(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{526:function(e,t,a){"use strict";a.r(t);var n=a(44),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"named-default-arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#named-default-arguments"}},[e._v("#")]),e._v(" Named & Default Arguments")]),e._v(" "),a("blockquote",[a("p",[e._v("You can provide argument names during a function call.")])]),e._v(" "),a("p",[e._v("Named arguments improve code readability. This is especially true for long and complex argument lists—named arguments can be clear enough that the reader can understand a function call without looking at the documentation.")]),e._v(" "),a("p",[e._v("In this example, all parameters are "),a("code",[e._v("Int")]),e._v(". Named arguments clarify their meaning:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/NamedArguments.kt\npackage color1\nimport atomictest.eq\n\nfun color(red: Int, green: Int, blue: Int) =\n  "($red, $green, $blue)"\n\nfun main() {\n  color(1, 2, 3) eq "(1, 2, 3)"   // [1]\n  color(\n    red = 76,                     // [2]\n    green = 89,\n    blue = 0\n  ) eq "(76, 89, 0)"\n  color(52, 34, blue = 0) eq      // [3]\n    "(52, 34, 0)"\n}\n')])])]),a("ul",[a("li",[a("strong",[e._v("[1]")]),e._v(" This doesn’t tell you much. You’ll have to look at the documentation to know what the arguments mean.")]),e._v(" "),a("li",[a("strong",[e._v("[2]")]),e._v(" The meaning of every argument is clear.")]),e._v(" "),a("li",[a("strong",[e._v("[3]")]),e._v(" You aren’t required to name all arguments.")])]),e._v(" "),a("p",[e._v("Named arguments allow you to change the order of the colors. Here, we specify "),a("code",[e._v("blue")]),e._v(" first:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/ArgumentOrder.kt\nimport color1.color\nimport atomictest.eq\n\nfun main() {\n  color(blue = 0, red = 99, green = 52) eq\n    "(99, 52, 0)"\n  color(red = 255, 255, 0) eq\n    "(255, 255, 0)"\n}\n')])])]),a("p",[e._v("You can mix named and regular (positional) arguments. If you change argument order, you should use named arguments throughout the call—not only for readability, but the compiler often needs to be told where the arguments are.")]),e._v(" "),a("p",[e._v("Named arguments are even more useful when combined with "),a("em",[e._v("default arguments")]),e._v(", which are default values for arguments, specified in the function definition:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/Color2.kt\npackage color2\nimport atomictest.eq\n\nfun color(\n  red: Int = 0,\n  green: Int = 0,\n  blue: Int = 0,\n) = "($red, $green, $blue)"\n\nfun main() {\n  color(139) eq "(139, 0, 0)"\n  color(blue = 139) eq "(0, 0, 139)"\n  color(255, 165) eq "(255, 165, 0)"\n  color(red = 128, blue = 128) eq\n    "(128, 0, 128)"\n}\n')])])]),a("p",[e._v("Any argument you don’t provide gets its default value, so you only need to provide arguments that differ from the defaults. If you have a long argument list, this simplifies the resulting code, making it easier to write and—more importantly—to read.")]),e._v(" "),a("p",[e._v("This example also uses a "),a("em",[e._v("trailing comma")]),e._v(" in the definition for "),a("code",[e._v("color()")]),e._v(". The trailing comma is the extra comma after the last parameter ("),a("code",[e._v("blue")]),e._v("). This is useful when your parameters or values are written on multiple lines. With a trailing comma, you can add new items and change their order without adding or removing commas.")]),e._v(" "),a("p",[e._v("Named and default arguments (as well as trailing commas) also work for constructors:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/Color3.kt\npackage color3\nimport atomictest.eq\n\nclass Color(\n  val red: Int = 0,\n  val green: Int = 0,\n  val blue: Int = 0,\n) {\n  override fun toString() =\n    "($red, $green, $blue)"\n}\n\nfun main() {\n  Color(red = 77).toString() eq "(77, 0, 0)"\n}\n')])])]),a("p",[a("code",[e._v("joinToString()")]),e._v(" is a standard library function that uses default arguments. It combines the contents of an iterable (a list, set or range) into a "),a("code",[e._v("String")]),e._v(". You can specify a separator, a prefix element and a postfix element:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/CreateString.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, 3,)\n  list.toString() eq "[1, 2, 3]"\n  list.joinToString() eq "1, 2, 3"\n  list.joinToString(prefix = "(",\n    postfix = ")") eq "(1, 2, 3)"\n  list.joinToString(separator = ":") eq\n    "1:2:3"\n}\n')])])]),a("p",[e._v("The default "),a("code",[e._v("toString()")]),e._v(" for a "),a("code",[e._v("List")]),e._v(" returns the contents in square brackets, which might not be what you want. The default values for "),a("code",[e._v("joinToString()")]),e._v("s parameters are a comma for "),a("code",[e._v("separator")]),e._v(" and empty "),a("code",[e._v("String")]),e._v("s for "),a("code",[e._v("prefix")]),e._v(" and "),a("code",[e._v("postfix")]),e._v(". In the above example, we use named and default arguments to specify only the arguments we want to change.")]),e._v(" "),a("p",[e._v("The initializer for "),a("code",[e._v("list")]),e._v(" includes a trailing comma. Normally you’ll only use a trailing comma when each element is on its own line.")]),e._v(" "),a("p",[e._v("If you use an object as a default argument, a new instance of that object is created for each invocation:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// NamedAndDefaultArgs/Evaluation.kt\npackage namedanddefault\n\nclass DefaultArg\n\nfun h(d: DefaultArg = DefaultArg()) =\n  println(d)\n\nfun main() {\n  h()\n  h()\n}\n/* Sample output:\nDefaultArg@28d93b30\nDefaultArg@1b6d3586\n*/\n")])])]),a("p",[e._v("The addresses of the "),a("code",[e._v("Default")]),e._v(" objects are different for the two calls to "),a("code",[e._v("h()")]),e._v(", showing that there are two distinct objects.")]),e._v(" "),a("p",[e._v("Specify argument names when they improve readability. Compare the following two calls to "),a("code",[e._v("joinToString()")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/CreateString2.kt\nimport atomictest.eq\n\nfun main() {\n  val list = listOf(1, 2, 3)\n  list.joinToString(". ", "", "!") eq\n    "1. 2. 3!"\n  list.joinToString(separator = ". ",\n    postfix = "!") eq "1. 2. 3!"\n}\n')])])]),a("p",[e._v("It’s hard to guess whether "),a("code",[e._v('". "')]),e._v(" or "),a("code",[e._v('""')]),e._v(" is a separator unless you memorize the parameter order, which is impractical.")]),e._v(" "),a("p",[e._v("As another example of default arguments, "),a("code",[e._v("trimMargin()")]),e._v(" is a standard library function that formats multi-line "),a("code",[e._v("String")]),e._v("s. It uses a margin prefix "),a("code",[e._v("String")]),e._v(" to establish the beginning of each line. "),a("code",[e._v("trimMargin()")]),e._v(" trims leading whitespace characters followed by the margin prefix from every line of the source "),a("code",[e._v("String")]),e._v(". It removes the first and last lines if they are blank:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// NamedAndDefaultArgs/TrimMargin.kt\nimport atomictest.eq\n\nfun main() {\n  val poem = """\n    |->Last night I saw upon the stair\n        |->A little man who wasn\'t there\n          |->He wasn\'t there again today\n|->Oh, how I wish he\'d go away."""\n  poem.trimMargin() eq\n"""->Last night I saw upon the stair\n->A little man who wasn\'t there\n->He wasn\'t there again today\n->Oh, how I wish he\'d go away."""\n  poem.trimMargin(marginPrefix = "|->") eq\n"""Last night I saw upon the stair\nA little man who wasn\'t there\nHe wasn\'t there again today\nOh, how I wish he\'d go away."""\n}\n')])])]),a("p",[e._v("The "),a("code",[e._v("|")]),e._v(" (“pipe”) is the default argument for the margin prefix, and you can replace it with a "),a("code",[e._v("String")]),e._v(" of your choosing.")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);