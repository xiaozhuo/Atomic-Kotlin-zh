(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{470:function(e,n,t){"use strict";t.r(n);var a=t(44),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"type-checking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#type-checking"}},[e._v("#")]),e._v(" Type Checking")]),e._v(" "),t("blockquote",[t("p",[e._v("In Kotlin you can easily act on an object based on its type. Normally this activity is the domain of polymorphism, so "),t("em",[e._v("type checking")]),e._v(" enables interesting design choices.")])]),e._v(" "),t("p",[e._v("Traditionally, type checking is used for special cases. For example, the majority of insects can fly, but there are a tiny number that cannot. It doesn’t make sense to burden the "),t("code",[e._v("Insect")]),e._v(" interface with the few insects that are unable to fly, so in "),t("code",[e._v("basic()")]),e._v(" we use type checking to pick those out:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/Insects.kt\npackage typechecking\nimport atomictest.eq\n\ninterface Insect {\n  fun walk() = "$name: walk"\n  fun fly() = "$name: fly"\n}\n\nclass HouseFly : Insect\n\nclass Flea : Insect {\n  override fun fly() =\n    throw Exception("Flea cannot fly")\n  fun crawl() = "Flea: crawl"\n}\n\nfun Insect.basic() =\n  walk() + " " +\n  if (this is Flea)\n    crawl()\n  else\n    fly()\n\ninterface SwimmingInsect: Insect {\n  fun swim() = "$name: swim"\n}\n\ninterface WaterWalker: Insect {\n  fun walkWater() =\n    "$name: walk on water"\n}\n\nclass WaterBeetle : SwimmingInsect\nclass WaterStrider : WaterWalker\nclass WhirligigBeetle :\n  SwimmingInsect, WaterWalker\n\nfun Insect.water() =\n  when(this) {\n    is SwimmingInsect -> swim()\n    is WaterWalker -> walkWater()\n    else -> "$name: drown"\n  }\n\nfun main() {\n  val insects = listOf(\n    HouseFly(), Flea(), WaterStrider(),\n    WaterBeetle(), WhirligigBeetle()\n  )\n  insects.map { it.basic() } eq\n    "[HouseFly: walk HouseFly: fly, " +\n    "Flea: walk Flea: crawl, " +\n    "WaterStrider: walk WaterStrider: fly, " +\n    "WaterBeetle: walk WaterBeetle: fly, " +\n    "WhirligigBeetle: walk " +\n    "WhirligigBeetle: fly]"\n  insects.map { it.water() } eq\n    "[HouseFly: drown, Flea: drown, " +\n    "WaterStrider: walk on water, " +\n    "WaterBeetle: swim, " +\n    "WhirligigBeetle: swim]"\n}\n')])])]),t("p",[e._v("There are also a very small number of insects that can walk on water or swim underwater. Again, it doesn’t make sense to put those special-case behaviors in the base class to support such a small fraction of types. Instead, "),t("code",[e._v("Insect.water()")]),e._v(" contains a "),t("code",[e._v("when")]),e._v(" expression that selects those subtypes for special behavior and assumes standard behavior for everything else.")]),e._v(" "),t("p",[e._v("Selecting a few isolated types for special treatment is the typical use case for type checking. Notice that adding new types to the system doesn’t impact the existing code (unless a new type also requires special treatment).")]),e._v(" "),t("p",[e._v("To simplify the code, "),t("code",[e._v("name")]),e._v(" produces the type of the object pointed to by the "),t("code",[e._v("this")]),e._v(" under question:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// TypeChecking/AnyName.kt\npackage typechecking\n\nval Any.name\n  get() = this::class.simpleName\n")])])]),t("p",[t("code",[e._v("name")]),e._v(" takes an "),t("code",[e._v("Any")]),e._v(" and gets the associated class reference using "),t("code",[e._v("::class")]),e._v(", then produces the "),t("code",[e._v("simpleName")]),e._v(" of that class.")]),e._v(" "),t("p",[e._v("Now consider a variation of the “shape” example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/TypeCheck1.kt\npackage typechecking\nimport atomictest.eq\n\ninterface Shape {\n  fun draw(): String\n}\n\nclass Circle : Shape {\n  override fun draw() = "Circle: Draw"\n}\n\nclass Square : Shape {\n  override fun draw() = "Square: Draw"\n  fun rotate() = "Square: Rotate"\n}\n\nfun turn(s: Shape) = when(s) {\n  is Square -> s.rotate()\n  else -> ""\n}\n\nfun main() {\n  val shapes = listOf(Circle(), Square())\n  shapes.map { it.draw() } eq\n    "[Circle: Draw, Square: Draw]"\n  shapes.map { turn(it) } eq\n    "[, Square: Rotate]"\n}\n')])])]),t("p",[e._v("There are several reasons why you might add "),t("code",[e._v("rotate()")]),e._v(" to "),t("code",[e._v("Square")]),e._v(" instead of "),t("code",[e._v("Shape")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("The "),t("code",[e._v("Shape")]),e._v(" interface is out of your control, so you cannot modify it.")]),e._v(" "),t("li",[e._v("Rotating "),t("code",[e._v("Square")]),e._v(" seems like a special case that shouldn’t burden and/or complicate the "),t("code",[e._v("Shape")]),e._v(" interface.")]),e._v(" "),t("li",[e._v("You’re just trying to quickly solve a problem by adding "),t("code",[e._v("Square")]),e._v(" and you don’t want to take the trouble of putting "),t("code",[e._v("rotate()")]),e._v(" in "),t("code",[e._v("Shape")]),e._v(" and implementing it in all the subtypes.")])]),e._v(" "),t("p",[e._v("There are certainly situations when this solution doesn’t negatively impact your design, and Kotlin’s "),t("code",[e._v("when")]),e._v(" produces clean and straightforward code.")]),e._v(" "),t("p",[e._v("If, however, you must evolve your system by adding more types, it begins to get messy:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/TypeCheck2.kt\npackage typechecking\nimport atomictest.eq\n\nclass Triangle : Shape {\n  override fun draw() = "Triangle: Draw"\n  fun rotate() = "Triangle: Rotate"\n}\n\nfun turn2(s: Shape) = when(s) {\n  is Square -> s.rotate()\n  is Triangle -> s.rotate()\n  else -> ""\n}\n\nfun main() {\n  val shapes =\n    listOf(Circle(), Square(), Triangle())\n  shapes.map { it.draw() } eq\n    "[Circle: Draw, Square: Draw, " +\n    "Triangle: Draw]"\n  shapes.map { turn(it) } eq\n    "[, Square: Rotate, ]"\n  shapes.map { turn2(it) } eq\n    "[, Square: Rotate, Triangle: Rotate]"\n}\n')])])]),t("p",[e._v("The polymorphic call in "),t("code",[e._v("shapes.map { it.draw() }")]),e._v(" adapts to the new "),t("code",[e._v("Triangle")]),e._v(" class without any changes or errors. Also, Kotlin disallows "),t("code",[e._v("Triangle")]),e._v(" unless it implements "),t("code",[e._v("draw()")]),e._v(".")]),e._v(" "),t("p",[e._v("The original "),t("code",[e._v("turn()")]),e._v(" doesn’t break when we add "),t("code",[e._v("Triangle")]),e._v(", but it also doesn’t produce the result we want. "),t("code",[e._v("turn()")]),e._v(" must become "),t("code",[e._v("turn2()")]),e._v(" to generate the desired behavior.")]),e._v(" "),t("p",[e._v("Suppose your system begins to accumulate more functions like "),t("code",[e._v("turn()")]),e._v(". The "),t("code",[e._v("Shape")]),e._v(" logic is now distributed across all these functions, rather than being centralized within the "),t("code",[e._v("Shape")]),e._v(" hierarchy. If you add more new types of "),t("code",[e._v("Shape")]),e._v(", you must search for every function containing a "),t("code",[e._v("when")]),e._v(" that switches on a "),t("code",[e._v("Shape")]),e._v(" type, and modify it to include the new case. If you miss any of these functions, the compiler won’t catch it.")]),e._v(" "),t("p",[t("code",[e._v("turn()")]),e._v(" and "),t("code",[e._v("turn2()")]),e._v(" exhibit what is often called "),t("em",[e._v("type-check coding")]),e._v(", which means testing for every type in your system. (If you are only looking for one or a few special types it is not usually considered type-check coding).")]),e._v(" "),t("p",[e._v("In traditional object-oriented languages, type-check coding is usually considered an antipattern because it invites the creation of one or more pieces of code that must be vigilantly maintained and updated whenever you add or change types in your system. Polymorphism, on the other hand, encapsulates those changes into the types that you add or modify, and those changes are then transparently propagated through your system.")]),e._v(" "),t("p",[e._v("Note that the problem only occurs when the system needs to evolve by adding more "),t("code",[e._v("Shape")]),e._v(" types. If that’s not how your system evolves, you won’t encounter the issue. If it is a problem it doesn’t usually happen suddenly, but becomes steadily more difficult as your system evolves.")]),e._v(" "),t("p",[e._v("We shall see that Kotlin significantly mitigates this problem through the use of "),t("code",[e._v("sealed")]),e._v(" classes. The solution isn’t perfect, but type checking becomes a much more reasonable design choice.")]),e._v(" "),t("h3",{attrs:{id:"type-checking-in-auxiliary-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#type-checking-in-auxiliary-functions"}},[e._v("#")]),e._v(" Type Checking in Auxiliary Functions")]),e._v(" "),t("p",[e._v("The essence of a "),t("code",[e._v("BeverageContainer")]),e._v(" is that it holds and delivers beverages. It seems to make sense to treat recycling as an auxiliary function:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/BeverageContainer.kt\npackage typechecking\nimport atomictest.eq\n\ninterface BeverageContainer {\n  fun open(): String\n  fun pour(): String\n}\n\nclass Can : BeverageContainer {\n  override fun open() = "Pop Top"\n  override fun pour() = "Can: Pour"\n}\n\nopen class Bottle : BeverageContainer {\n  override fun open() = "Remove Cap"\n  override fun pour() = "Bottle: Pour"\n}\n\nclass GlassBottle : Bottle()\nclass PlasticBottle : Bottle()\n\nfun BeverageContainer.recycle() =\n  when(this) {\n    is Can -> "Recycle Can"\n    is GlassBottle -> "Recycle Glass"\n    else -> "Landfill"\n  }\n\nfun main() {\n  val refrigerator = listOf(\n    Can(), GlassBottle(), PlasticBottle()\n  )\n  refrigerator.map { it.open() } eq\n    "[Pop Top, Remove Cap, Remove Cap]"\n  refrigerator.map { it.recycle() } eq\n    "[Recycle Can, Recycle Glass, " +\n    "Landfill]"\n}\n')])])]),t("p",[e._v("By defining "),t("code",[e._v("recycle()")]),e._v(" as an auxiliary function it captures the different recycling behaviors in a single place, rather than having them distributed throughout the "),t("code",[e._v("BeverageContainer")]),e._v(" hierarchy by making "),t("code",[e._v("recycle()")]),e._v(" a member function.")]),e._v(" "),t("p",[e._v("Acting on types with "),t("code",[e._v("when")]),e._v(" is clean and straightforward, but the design is still problematic. When you add a new type, "),t("code",[e._v("recycle()")]),e._v(" quietly uses the "),t("code",[e._v("else")]),e._v(" clause. Because of this, necessary changes to type-checking functions like "),t("code",[e._v("recycle()")]),e._v(" might be missed. What we’d like is for the compiler to tell us that we’ve forgotten a type check, just as it does when we implement an interface or inherit an "),t("code",[e._v("abstract")]),e._v(" class and it tells us we’ve forgotten to override a function.")]),e._v(" "),t("p",[t("code",[e._v("sealed")]),e._v(" classes provide a significant improvement here. Making "),t("code",[e._v("Shape")]),e._v(" a "),t("code",[e._v("sealed")]),e._v(" class means that the "),t("code",[e._v("when")]),e._v(" in "),t("code",[e._v("turn()")]),e._v(" (after removing the "),t("code",[e._v("else")]),e._v(") requires that each type be checked. Interfaces cannot be "),t("code",[e._v("sealed")]),e._v(" so we must rewrite "),t("code",[e._v("Shape")]),e._v(" into a class:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/TypeCheck3.kt\npackage typechecking3\nimport atomictest.eq\nimport typechecking.name\n\nsealed class Shape {\n  fun draw() = "$name: Draw"\n}\n\nclass Circle : Shape()\n\nclass Square : Shape() {\n  fun rotate() = "Square: Rotate"\n}\n\nclass Triangle : Shape() {\n  fun rotate() = "Triangle: Rotate"\n}\n\nfun turn(s: Shape) = when(s) {\n  is Circle -> ""\n  is Square -> s.rotate()\n  is Triangle -> s.rotate()\n}\n\nfun main() {\n  val shapes = listOf(Circle(), Square())\n  shapes.map { it.draw() } eq\n    "[Circle: Draw, Square: Draw]"\n  shapes.map { turn(it) } eq\n    "[, Square: Rotate]"\n}\n')])])]),t("p",[e._v("If we add a new "),t("code",[e._v("Shape")]),e._v(", the compiler tells us to add a new type-check path in "),t("code",[e._v("turn()")]),e._v(".")]),e._v(" "),t("p",[e._v("But let’s look at what happens when we try to apply "),t("code",[e._v("sealed")]),e._v(" to the "),t("code",[e._v("BeverageContainer")]),e._v(" problem. In the process, we create additional "),t("code",[e._v("Can")]),e._v(" and "),t("code",[e._v("Bottle")]),e._v(" subtypes:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/BeverageContainer2.kt\npackage typechecking2\nimport atomictest.eq\n\nsealed class BeverageContainer {\n  abstract fun open(): String\n  abstract fun pour(): String\n}\n\nsealed class Can : BeverageContainer() {\n  override fun open() = "Pop Top"\n  override fun pour() = "Can: Pour"\n}\n\nclass SteelCan : Can()\nclass AluminumCan : Can()\n\nsealed class Bottle : BeverageContainer() {\n  override fun open() = "Remove Cap"\n  override fun pour() = "Bottle: Pour"\n}\n\nclass GlassBottle : Bottle()\nsealed class PlasticBottle : Bottle()\nclass PETBottle : PlasticBottle()\nclass HDPEBottle : PlasticBottle()\n\nfun BeverageContainer.recycle() =\n  when(this) {\n    is Can -> "Recycle Can"\n    is Bottle -> "Recycle Bottle"\n  }\n\nfun BeverageContainer.recycle2() =\n  when(this) {\n    is Can -> when(this) {\n      is SteelCan -> "Recycle Steel"\n      is AluminumCan -> "Recycle Aluminum"\n    }\n    is Bottle -> when(this) {\n      is GlassBottle -> "Recycle Glass"\n      is PlasticBottle -> when(this) {\n        is PETBottle -> "Recycle PET"\n        is HDPEBottle -> "Recycle HDPE"\n      }\n    }\n  }\n\nfun main() {\n  val refrigerator = listOf(\n    SteelCan(), AluminumCan(),\n    GlassBottle(),\n    PETBottle(), HDPEBottle()\n  )\n  refrigerator.map { it.open() } eq\n    "[Pop Top, Pop Top, Remove Cap, " +\n    "Remove Cap, Remove Cap]"\n  refrigerator.map { it.recycle() } eq\n    "[Recycle Can, Recycle Can, " +\n    "Recycle Bottle, Recycle Bottle, " +\n    "Recycle Bottle]"\n  refrigerator.map { it.recycle2() } eq\n    "[Recycle Steel, Recycle Aluminum, " +\n    "Recycle Glass, " +\n    "Recycle PET, Recycle HDPE]"\n}\n')])])]),t("p",[e._v("Note that the intermediate classes "),t("code",[e._v("Can")]),e._v(" and "),t("code",[e._v("Bottle")]),e._v(" must also be "),t("code",[e._v("sealed")]),e._v(" for this approach to work.")]),e._v(" "),t("p",[e._v("As long as the classes are direct subclasses of "),t("code",[e._v("BeverageContainer")]),e._v(", the compiler guarantees that the "),t("code",[e._v("when")]),e._v(" in "),t("code",[e._v("recycle()")]),e._v(" is exhaustive. But subclasses like "),t("code",[e._v("GlassBottle")]),e._v(" and "),t("code",[e._v("AluminumCan")]),e._v(" are not checked. To solve the problem we must explicitly include the nested "),t("code",[e._v("when")]),e._v(" expressions seen in "),t("code",[e._v("recycle2()")]),e._v(", at which point the compiler "),t("em",[e._v("does")]),e._v(" require exhaustive type checks (try commenting one of the specific "),t("code",[e._v("Can")]),e._v(" or "),t("code",[e._v("Bottle")]),e._v(" types to verify this).")]),e._v(" "),t("p",[e._v("To create a robust type-checking solution you must rigorously use "),t("code",[e._v("sealed")]),e._v(" at each intermediate level of the class hierarchy, while ensuring that each level of subclasses has a corresponding nested "),t("code",[e._v("when")]),e._v(". In this case, if you add a new subtype of "),t("code",[e._v("Can")]),e._v(" or "),t("code",[e._v("Bottle")]),e._v(" the compiler ensures that "),t("code",[e._v("recycle2()")]),e._v(" tests for each subtype.")]),e._v(" "),t("p",[e._v("Although not as clean as polymorphism, this is a significant improvement over prior object-oriented languages, and allows you to choose whether to write a polymorphic member function or auxiliary function. Notice that this problem only occurs when you have multiple levels of inheritance.")]),e._v(" "),t("p",[e._v("For comparison, let’s rewrite "),t("code",[e._v("BeverageContainer2.kt")]),e._v(" by bringing "),t("code",[e._v("recycle()")]),e._v(" into "),t("code",[e._v("BeverageContainer")]),e._v(", which can again be an "),t("code",[e._v("interface")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// TypeChecking/BeverageContainer3.kt\npackage typechecking3\nimport atomictest.eq\nimport typechecking.name\n\ninterface BeverageContainer {\n  fun open(): String\n  fun pour() = "$name: Pour"\n  fun recycle(): String\n}\n\nabstract class Can : BeverageContainer {\n  override fun open() = "Pop Top"\n}\n\nclass SteelCan : Can() {\n  override fun recycle() = "Recycle Steel"\n}\n\nclass AluminumCan : Can() {\n  override fun recycle() = "Recycle Aluminum"\n}\n\nabstract class Bottle : BeverageContainer {\n  override fun open() = "Remove Cap"\n}\n\nclass GlassBottle : Bottle() {\n  override fun recycle() = "Recycle Glass"\n}\n\nabstract class PlasticBottle : Bottle()\n\nclass PETBottle : PlasticBottle() {\n  override fun recycle() = "Recycle PET"\n}\n\nclass HDPEBottle : PlasticBottle() {\n  override fun recycle() = "Recycle HDPE"\n}\n\nfun main() {\n  val refrigerator = listOf(\n    SteelCan(), AluminumCan(),\n    GlassBottle(),\n    PETBottle(), HDPEBottle()\n  )\n  refrigerator.map { it.open() } eq\n    "[Pop Top, Pop Top, Remove Cap, " +\n    "Remove Cap, Remove Cap]"\n  refrigerator.map { it.recycle() } eq\n    "[Recycle Steel, Recycle Aluminum, " +\n    "Recycle Glass, " +\n    "Recycle PET, Recycle HDPE]"\n}\n')])])]),t("p",[e._v("By making "),t("code",[e._v("Can")]),e._v(" and "),t("code",[e._v("Bottle")]),e._v(" "),t("code",[e._v("abstract")]),e._v(" classes, we force their subclasses to override "),t("code",[e._v("recycle()")]),e._v(" in the same way that the compiler forces each type to be checked inside "),t("code",[e._v("recycle2()")]),e._v(" in "),t("code",[e._v("BeverageContainer2.kt")]),e._v(".")]),e._v(" "),t("p",[e._v("Now the behavior of "),t("code",[e._v("recycle()")]),e._v(" is distributed among the classes, which might be fine—it’s  a design decision. If you decide that recycling behavior changes often and you’d like to have it all in one place, then using the auxiliary type-checked "),t("code",[e._v("recycle2()")]),e._v(" from "),t("code",[e._v("BeverageContainer2.kt")]),e._v(" might be a better choice for your needs, and Kotlin’s features make that reasonable.")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Exercises and solutions can be found at www.AtomicKotlin.com.")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);